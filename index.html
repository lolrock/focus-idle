<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Focus Idle (v5.3)</title>
  <style>
    :root { --bg:#000; --fg:#fff; --muted:rgba(255,255,255,.65); --dim:rgba(255,255,255,.25); }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--fg);
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,AppleSDGothicNeo,Helvetica,Arial,sans-serif; }
    .app { height:100%; display:flex; flex-direction:column; }
    .top {
      padding:14px 16px 8px; font-size:12px; color:var(--muted);
      display:flex; justify-content:space-between; align-items:center; gap:10px;
    }
    .topRightWrap{ display:flex; align-items:center; gap:10px; }
    .gear {
      width:34px; height:34px; border-radius:10px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.06);
      color:var(--fg);
      display:flex; align-items:center; justify-content:center;
      cursor:pointer;
      user-select:none;
    }
    .gear:active { transform:scale(.98); }
    .center { flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center; padding:16px; }
    .label { font-size:12px; color:var(--muted); letter-spacing:.12em; }
    .points { font-size:56px; font-weight:700; margin:10px 0 6px; }
    .status { margin-top:14px; font-size:14px; color:var(--muted); line-height:1.6; }
    .bottom { padding:10px 12px 16px; position:sticky; bottom:0;
      background:linear-gradient(to top, rgba(0,0,0,.95), rgba(0,0,0,.65), rgba(0,0,0,0)); }
    .btnrow { display:flex; gap:10px; }
    button {
      flex:1; border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.06); color:var(--fg);
      padding:14px 10px; border-radius:12px; font-size:14px; cursor:pointer;
    }
    button:disabled { opacity:.35; cursor:not-allowed; }

    .overlay, .modal { position:fixed; inset:0; background:rgba(0,0,0,.92); display:none; z-index:20; }
    .panel { max-width:520px; margin:0 auto; height:100%; display:flex; flex-direction:column; }
    .panelTop { padding:14px 16px; display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid rgba(255,255,255,.14); }
    .panelTop h2 { margin:0; font-size:14px; font-weight:700; letter-spacing:.06em; color:var(--fg); }
    .panelTop button { flex:0 0 auto; padding:10px 12px; border-radius:10px; }
    .panelBody { padding:14px 16px; overflow:auto; }
    .row { padding:12px 0; border-bottom:1px solid rgba(255,255,255,.10); }
    .rowHead { display:flex; justify-content:space-between; align-items:baseline; gap:10px; }
    .rowHead .name { font-size:13px; color:var(--muted); }
    .rowHead .val { font-size:18px; font-weight:700; }
    .rowBtns { display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
    .mini { flex:0 0 auto; padding:10px 12px; border-radius:10px; font-size:13px; }
    .hint { margin:8px 0 0; color:var(--dim); font-size:12px; }

    .toast {
      position:fixed; left:50%; bottom:92px; transform:translateX(-50%);
      background:rgba(255,255,255,.10); border:1px solid rgba(255,255,255,.18);
      color:var(--fg); padding:10px 12px; border-radius:12px; font-size:13px;
      display:none; z-index:50;
      max-width:min(520px, calc(100% - 24px));
    }

    /* Battle */
    .battleBox { padding:16px; }
    .bigline { font-size:14px; font-weight:700; margin:8px 0 12px; color:rgba(255,255,255,.85); line-height:1.55; }
    .hpbox { display:flex; justify-content:space-between; gap:12px; color:var(--muted); font-size:13px; }
    .hpn { font-size:22px; color:var(--fg); font-weight:800; margin-top:6px; }
    .log {
      margin-top:14px; color:var(--muted); font-size:14px; line-height:1.7;
      height:240px; overflow:auto;
      border:1px solid rgba(255,255,255,.10); border-radius:12px;
      padding:10px 12px;
    }
    .crit { color:var(--fg); }
    .resultCenter { height:100%; display:flex; flex-direction:column; justify-content:center; align-items:center; text-align:center; padding:18px; gap:10px; }
    .resultTitle { font-size:28px; font-weight:800; }
    .resultSub { color:var(--muted); font-size:14px; line-height:1.6; }
    .overkill { margin-top:8px; font-weight:800; letter-spacing:.08em; }
    .skipLine { color:var(--muted); font-size:14px; min-height:22px; }
    .confirmBtn { width:min(320px, 92%); }
    .smallTop { color:var(--muted); font-size:12px; }

    /* OFF black screen mode (when growing) */
    .offFocus { background:#000 !important; }
    .offFocus .top,
    .offFocus .center,
    .offFocus .bottom{
      background:#000 !important;
    }
    .offFocus .label,
    .offFocus .points,
    .offFocus #liveGain,
    .offFocus #status,
    .offFocus #rebirthInfo{
      display:none !important;
    }
    .elapsedOnly {
      font-size:44px;
      font-weight:800;
      letter-spacing:.02em;
      color:rgba(255,255,255,.90);
    }
    .elapsedSub {
      margin-top:10px;
      font-size:12px;
      color:rgba(255,255,255,.35);
    }
    .stealthPeek {
      margin-top:12px;
      font-size:14px;
      color:rgba(255,255,255,.70);
      line-height:1.55;
      display:none;
      white-space:pre-line;
    }
  </style>
</head>
<body>
<div class="app" id="appRoot">
  <div class="top">
    <div id="topLeft">Enemy Lv 1</div>
    <div class="topRightWrap">
      <div id="topRight">C0 5.00 | C 5.00</div>
      <div class="gear" id="btnSettings" title="설정" aria-label="설정">⚙︎</div>
    </div>
  </div>

  <div class="center">
    <!-- OFF 모드 집중중일 때만 표시 -->
    <div id="elapsedOnlyBox" style="display:none;">
      <div class="elapsedOnly" id="elapsedOnly">00:00</div>
      <div class="elapsedSub" id="elapsedSub">집중 중 (탭하면 잠깐 표시)</div>
      <div class="stealthPeek" id="stealthPeek"></div>
    </div>

    <div class="label">POINTS</div>
    <div class="points" id="points">0</div>
    <div class="status" id="liveGain" style="margin-top:6px; font-size:13px; color:rgba(255,255,255,.55); display:none;"></div>
    <div class="status" id="status"></div>
    <div class="status" id="rebirthInfo" style="margin-top:10px; color:rgba(255,255,255,.35); font-size:12px;"></div>
  </div>

  <div class="bottom" id="bottomBar">
    <div class="btnrow" id="btnRowNormal">
      <button id="btnUpgrade">업그레이드</button>
      <button id="btnBattle">전투</button>
      <button id="btnGrow">집중하기</button>
    </div>

    <!-- OFF 모드 집중중일 때만 사용: 정산하기 단독 -->
    <div class="btnrow" id="btnRowSettleOnly" style="display:none;">
      <button id="btnSettleOnly">정산하기</button>
    </div>
  </div>
</div>

<!-- Settings -->
<div class="overlay" id="settingsOverlay" aria-hidden="true">
  <div class="panel">
    <div class="panelTop">
      <h2>설정</h2>
      <button id="btnSettingsClose" class="mini">닫기</button>
    </div>
    <div class="panelBody">
      <div class="row">
        <div class="rowHead">
          <div class="name">표시</div>
          <div class="val" id="vDisplayMode">ON</div>
        </div>
        <div class="rowBtns">
          <button class="mini" id="optDisplayOn">ON</button>
          <button class="mini" id="optDisplayOff">OFF</button>
        </div>
        <div class="hint">OFF + 집중중: 블랙스크린(경과시간) + 정산 버튼만 (탭하면 잠깐 표시)</div>
      </div>

      <div class="row">
        <div class="rowHead">
          <div class="name">갱신 주기</div>
          <div class="val" id="vRefresh">1초</div>
        </div>
        <div class="rowBtns">
          <button class="mini" id="optT1">1초</button>
          <button class="mini" id="optT60">1분</button>
          <button class="mini" id="optT300">5분</button>
        </div>
        <div class="hint">집중중 화면 갱신(표시 ON이면 포인트/예상치 갱신, OFF면 경과시간 갱신)</div>
      </div>

      <div class="row">
        <div class="hint">저장은 localStorage의 key <b>focus_idle_save</b>에 저장됩니다.</div>
      </div>
    </div>
  </div>
</div>

<!-- Upgrade -->
<div class="overlay" id="upgradeOverlay" aria-hidden="true">
  <div class="panel">
    <div class="panelTop">
      <h2>업그레이드</h2>
      <button id="btnUpgradeClose" class="mini">닫기</button>
    </div>
    <div class="panelBody">
      <div class="row">
        <div class="rowHead">
          <div class="name">포인트</div>
          <div class="val" id="uPoints">0</div>
        </div>
      </div>

      <div class="row">
        <div class="rowHead"><div class="name">ATK</div><div class="val" id="vATK">0</div></div>
        <div class="rowBtns" id="bATK"></div>
      </div>

      <div class="row">
        <div class="rowHead"><div class="name">DEF</div><div class="val" id="vDEF">0</div></div>
        <div class="rowBtns" id="bDEF"></div>
      </div>

      <div class="row">
        <div class="rowHead"><div class="name">MATK</div><div class="val" id="vMATK">0</div></div>
        <div class="rowBtns" id="bMATK"></div>
      </div>

      <div class="row">
        <div class="rowHead"><div class="name">MDEF</div><div class="val" id="vMDEF">0</div></div>
        <div class="rowBtns" id="bMDEF"></div>
      </div>

      <div class="row">
        <div class="hint">ATK/DEF/MATK/MDEF 비용은 <b>통합</b>입니다. (10pt 시작, 구매 1회마다 1.5배) · 환생 시 구매횟수만 초기화</div>
      </div>

      <div class="row" id="rowCrit">
        <div class="rowHead"><div class="name">CRIT%</div><div class="val" id="vCrit">0%</div></div>
        <div class="rowBtns" id="bCrit"></div>
        <div class="hint">0% 시작, 상한 90%, 비용 10×2^현재%</div>
      </div>

      <div class="row" id="rowCritDmg">
        <div class="rowHead"><div class="name">CRIT+</div><div class="val" id="vCritDmg">+50%</div></div>
        <div class="rowBtns" id="bCritDmg"></div>
        <div class="hint">추가 피해량 +50% 시작, +5% 단위, 상한 없음, 비용 10×2^업횟수</div>
      </div>

      <div class="row">
        <div class="rowHead"><div class="name">환생</div><div class="val" id="vRebirth">-</div></div>
        <div class="rowBtns">
          <button id="btnRebirth" class="mini">환생</button>
        </div>
        <div class="hint">조건: 환생 이후 집중 누적 50분(3000초) 이상</div>
      </div>

      <div class="row">
        <div class="hint">Tip: 아이폰에서 탭이 꺼지거나 다른 앱으로 가면 자동 정산 후 집중 종료됩니다.</div>
      </div>
    </div>
  </div>
</div>

<!-- Battle -->
<div class="overlay" id="battleOverlay" aria-hidden="true">
  <div class="panel">
    <div class="panelTop">
      <h2>전투</h2>
      <button id="btnBattleExit" class="mini">나가기</button>
    </div>
    <div class="panelBody battleBox">
      <div class="smallTop" id="battleTop">Enemy Lv 1</div>
      <div class="bigline" id="statsLine">-</div>

      <div class="hpbox">
        <div style="flex:1;">
          <div>적 HP</div>
          <div class="hpn" id="enemyHPpct">100%</div>
        </div>
        <div style="flex:1;">
          <div>내 HP</div>
          <div class="hpn" id="meHPpct">100%</div>
        </div>
      </div>

      <div class="status" style="margin-top:10px;">
        TURN <span id="turn">0</span>/<span id="turnLimit">30</span>
      </div>

      <div id="modeChooser" style="margin-top:14px; display:flex; gap:10px;">
        <button id="btnStartPhy">물리로 도전</button>
        <button id="btnStartMag">마법으로 도전</button>
      </div>
      <div class="status" id="modeFixed" style="margin-top:10px; display:none;"></div>

      <div class="log" id="log"></div>

      <div style="margin-top:12px;">
        <button id="btnStep" class="mini" style="width:100%;">1턴 진행</button>
      </div>
      <div class="hint" style="margin-top:10px;">자동으로 0.1초에 1턴 진행됩니다. (선택한 타입 고정)</div>
    </div>
  </div>
</div>

<!-- Result -->
<div class="modal" id="resultModal" aria-hidden="true">
  <div class="resultCenter">
    <div class="resultTitle" id="resultTitle">승리</div>
    <div class="resultSub" id="resultSub">-</div>
    <div class="overkill" id="overkill" style="display:none;">OVERKILL!</div>
    <div class="skipLine" id="skipLine"></div>
    <button id="btnConfirm" class="confirmBtn">확인</button>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
(() => {
  const KEY = "focus_idle_save";

  // ---------- Utilities ----------
  const now = () => Date.now();
  const fmt = (n) => {
    if (typeof n !== "number") return String(n);
    if (n >= 1e9) return (n/1e9).toFixed(2) + "B";
    if (n >= 1e6) return (n/1e6).toFixed(2) + "M";
    if (n >= 1e3) return Math.floor(n).toLocaleString("en-US");
    return (Math.floor(n)).toString();
  };
  const fmt2 = (n) => (Math.round(n * 100) / 100).toFixed(2);
  function $(sel){ return document.querySelector(sel); }
  function pad2(n){ return String(n).padStart(2,"0"); }
  function fmtTime(sec){
    const m = Math.floor(sec/60);
    const s = sec%60;
    return `${pad2(m)}:${pad2(s)}`;
  }
  function escapeHtml(s){
    return s.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }
  function toast(msg) {
    const el = $("#toast");
    el.textContent = msg;
    el.style.display = "block";
    clearTimeout(toast._t);
    toast._t = setTimeout(() => el.style.display = "none", 900);
  }

  // ---------- Core State ----------
  const DEFAULT = {
    points: 0,

    atk: 5, def: 5, matk: 5, mdef: 5,
    statBuys: 0,        // ATK/DEF/MATK/MDEF 공용 구매횟수(비용 증가용, 환생 시 0)

    critChance: 0,      // %
    critDmgUp: 0,       // bonus = 50 + 5*critDmgUp

    enemyLevel: 1,
    enemyBasePower: 30,
    enemyType: "PHY",
    enemyIsMidBoss: false,
    enemyAtk: 10, enemyDef: 10, enemyMAtk: 5, enemyMDef: 5,

    isGrowing: false,
    growStartAt: 0,

    c0: 5.0,
    maxLevelThisLife: 1,
    focusSecondsSinceRebirth: 0,
    rebirthCount: 0,

    ui: { display: "ON", refreshSec: 1 }
  };

  let S = load();

  // ---------- Derived ----------
  function isMidBossLevel(level){ return (level % 5) === 0; }

  function enemyPowerForLevel(level){
    const k = level - 1;
    return Math.floor(S.enemyBasePower * Math.pow(1.1, k));
  }
  function currentC(){
    return S.c0 + Math.floor((S.enemyLevel - 1) / 3);
  }
  function efficiencyPct(tSec){
    if (tSec >= 300) return 100;
    if (tSec >= 180) return 80;
    if (tSec >= 120) return 60;
    if (tSec >= 60)  return 40;
    return 20;
  }
  function critBonusPct(){ return 50 + 5 * S.critDmgUp; }

  // HP: 공2 / 방10
  function playerMaxHP(){
    return Math.max(1, (S.atk*2 + S.def*10 + S.matk*2 + S.mdef*10));
  }
  function enemyMaxHPFromStats(a,d,ma,md){
    return Math.max(1, (a*2 + d*10 + ma*2 + md*10));
  }
  function playerPowerMetric(){
    // 오버킬 계산용(기존 느낌 유지)
    return (S.atk + S.def + S.matk + S.mdef);
  }
  function enemyPowerMetricFromStats(a,d,ma,md){
    return (a + d + ma + md);
  }

  // ---------- Enemy generation ----------
  function regenEnemyForLevel(){
    const power = enemyPowerForLevel(S.enemyLevel);
    S.enemyType = (Math.random() < 0.5) ? "PHY" : "MAG";
    S.enemyIsMidBoss = isMidBossLevel(S.enemyLevel);

    const phyPower = Math.max(1, Math.floor(power * (S.enemyType === "PHY" ? 0.8 : 0.2)));
    const magPower = Math.max(1, Math.floor(power * (S.enemyType === "MAG" ? 0.8 : 0.2)));

    const r1 = 0.35 + Math.random() * 0.30;
    S.enemyAtk = Math.max(1, Math.round(phyPower * r1));
    S.enemyDef = Math.max(0, phyPower - S.enemyAtk);

    const r2 = 0.35 + Math.random() * 0.30;
    S.enemyMAtk = Math.max(1, Math.round(magPower * r2));
    S.enemyMDef = Math.max(0, magPower - S.enemyMAtk);

    // MID BOSS: 타입에 따라 방어 2배
    if (S.enemyIsMidBoss) {
      if (S.enemyType === "PHY") S.enemyDef *= 2;
      else S.enemyMDef *= 2;
    }

    save();
  }
  if (!S.enemyAtk || S.enemyMAtk == null || S.enemyMDef == null || !S.enemyType) regenEnemyForLevel();

  // ---------- Growth ----------
  function startGrowth(){
    if (S.isGrowing) return;
    S.isGrowing = true;
    S.growStartAt = now();
    save();
    render();
  }
  function calcGrowthPreview(){
    const tSec = Math.max(0, Math.floor((now() - S.growStartAt) / 1000));
    const eff = efficiencyPct(tSec);
    const E = eff / 100;
    const C = currentC();
    const gain = Math.floor(tSec * C * E);
    return { tSec, eff, gain };
  }
  function settleGrowth(){
    if (!S.isGrowing) return;
    const { tSec, gain } = calcGrowthPreview();

    S.points += gain;
    S.focusSecondsSinceRebirth += tSec;

    S.isGrowing = false;
    S.growStartAt = 0;
    save();
    render();
    if (tSec > 0) toast(`정산 +${fmt(gain)} (${tSec}s)`);
  }
  document.addEventListener("visibilitychange", () => { if (document.hidden) settleGrowth(); });
  window.addEventListener("pagehide", () => settleGrowth());

  // ---------- Unified STAT costs (x1.5 each buy) ----------
  const STAT_BASE_COST = 10;
  const STAT_GROWTH = 1.5;

  function statNextCost(buyIndex){
    return STAT_BASE_COST * Math.pow(STAT_GROWTH, buyIndex);
  }
  function statCostForN(startBuyIndex, n){
    if (n <= 0) return 0;
    const a = STAT_BASE_COST * Math.pow(STAT_GROWTH, startBuyIndex);
    return a * (Math.pow(STAT_GROWTH, n) - 1) / (STAT_GROWTH - 1);
  }
  function maxAffordableStatN(points){
    // UX 상 MAX는 100까지만
    let n = 0;
    let cost = 0;
    while (n < 100) {
      const c = statNextCost(S.statBuys + n);
      if (cost + c > points + 1e-9) break;
      cost += c;
      n++;
    }
    return n;
  }
  function applyStatUpgrade(statKey, n){
    if (n <= 0) return false;
    const cost = statCostForN(S.statBuys, n);
    if (cost > S.points + 1e-9) return false;

    S.points -= cost;
    S[statKey] += n;
    S.statBuys += n;
    save(); render();
    return true;
  }

  // ---------- Crit costs ----------
  function critChanceCost(c){ return 10 * Math.pow(2, c); }
  function applyCritChance(delta){
    if (delta <= 0) return false;
    const target = Math.min(90, S.critChance + delta);
    const realDelta = target - S.critChance;
    if (realDelta <= 0) return false;

    let cost = 0;
    for (let i=0;i<realDelta;i++){
      cost += critChanceCost(S.critChance + i);
      if (cost > S.points + 1e-9) return false;
    }
    S.points -= cost;
    S.critChance += realDelta;
    save(); render();
    return true;
  }

  function critDmgCost(k){ return 10 * Math.pow(2, k); }
  function applyCritDmgUp(deltaUpgrades){
    if (deltaUpgrades <= 0) return false;
    let cost = 0;
    for (let i=0;i<deltaUpgrades;i++){
      cost += critDmgCost(S.critDmgUp + i);
      if (cost > S.points + 1e-9) return false;
    }
    S.points -= cost;
    S.critDmgUp += deltaUpgrades;
    save(); render();
    return true;
  }

  // ---------- Battle ----------
  const TURN_LIMIT = 30;
  const LOG_LIMIT = 30;

  const TURN_MS = 100;            // 0.1초 / 턴
  const OVERKILL_HP_PCT = 0.90;   // 남은 HP 90% 이상이면 OVERKILL
  const SKIP2_HP_PCT = 0.50;      // 남은 HP 50% 이상이면 +2레벨

  let battle = null;
  let battleTimer = null;

  function sqrDmg(att, def){
    const diff = att - def;
    if (diff <= 0) return 1;          // 바닥딜
    const v = diff * diff;
    return (v >= 1 ? v : 1);
  }

  function pushLog(line, highlight=false){
    battle.log.push({ line, highlight });
    if (battle.log.length > LOG_LIMIT) battle.log.shift();
  }

  function showBattle(on){
    $("#battleOverlay").style.display = on ? "block" : "none";
    $("#battleOverlay").setAttribute("aria-hidden", on ? "false" : "true");
  }
  function showUpgrade(on){
    $("#upgradeOverlay").style.display = on ? "block" : "none";
    $("#upgradeOverlay").setAttribute("aria-hidden", on ? "false" : "true");
  }
  function showResult(on){
    $("#resultModal").style.display = on ? "block" : "none";
  }
  function showSettings(on){
    $("#settingsOverlay").style.display = on ? "block" : "none";
    $("#settingsOverlay").setAttribute("aria-hidden", on ? "false" : "true");
    if (on) renderSettings();
  }

  function openBattle(){
    if (S.isGrowing) return;

    const maxHP = playerMaxHP();

    battle = {
      chosenMode: null, // "phy" | "mag"
      enemyType: S.enemyType,
      enemyIsMidBoss: !!S.enemyIsMidBoss,
      enemyAtk: S.enemyAtk,
      enemyDef: S.enemyDef,
      enemyMAtk: S.enemyMAtk,
      enemyMDef: S.enemyMDef,
      enemyMaxHP: 0,
      enemyHP: 0,
      meMaxHP: maxHP,
      meHP: maxHP,
      turn: 0,
      log: [],
      _busy: false
    };

    battle.enemyMaxHP = enemyMaxHPFromStats(battle.enemyAtk, battle.enemyDef, battle.enemyMAtk, battle.enemyMDef);
    battle.enemyHP = battle.enemyMaxHP;

    $("#modeChooser").style.display = "flex";
    $("#modeFixed").style.display = "none";
    $("#btnStep").disabled = true;

    showBattle(true);
    renderBattle();
  }

  function startBattleLoop(){
    stopBattleLoop();
    battleTimer = setInterval(() => {
      if (!battle) return;
      if ($("#battleOverlay").style.display !== "block") return;
      if (!battle.chosenMode) return;
      doTurn(battle.chosenMode);
    }, TURN_MS);
  }
  function stopBattleLoop(){
    if (battleTimer) { clearInterval(battleTimer); battleTimer = null; }
  }

  function rollCrit(){
    const roll = Math.random() * 100;
    return roll < S.critChance;
  }
  function applyCritToDmg(base, isCrit){
    if (!isCrit) return base;
    const mult = 1 + (critBonusPct() / 100);
    return Math.max(1, Math.floor(base * mult));
  }

  function playerDamageToEnemy(mode){
    if (mode === "phy") {
      const base = sqrDmg(S.atk, battle.enemyDef);
      const isCrit = rollCrit();
      const dmg = applyCritToDmg(base, isCrit);
      return { dmg, isCrit, tag: "PHY" };
    } else {
      const base = sqrDmg(S.matk, battle.enemyMDef);
      const isCrit = rollCrit();
      const dmg = applyCritToDmg(base, isCrit);
      return { dmg, isCrit, tag: "MAG" };
    }
  }

  function enemyDamageToPlayer(){
    if (battle.enemyType === "PHY") {
      const dmg = sqrDmg(battle.enemyAtk, S.def);
      return { dmg, tag: "PHY" };
    } else {
      const dmg = sqrDmg(battle.enemyMAtk, S.mdef);
      return { dmg, tag: "MAG" };
    }
  }

  async function doTurn(mode){
    if (!battle) return;
    if (battle._busy) return;
    if (!battle.chosenMode) return;
    battle._busy = true;

    try {
      battle.turn += 1;

      // Player hits
      const p = playerDamageToEnemy(mode);
      battle.enemyHP = Math.max(0, battle.enemyHP - p.dmg);
      pushLog(`${p.isCrit ? "CRIT! " : ""}YOU(${p.tag}): -${p.dmg}`, p.isCrit);

      if (battle.enemyHP <= 0) {
        await endBattle(true, false, false);
        return;
      }

      // Enemy counters
      const e = enemyDamageToPlayer();
      battle.meHP = Math.max(0, battle.meHP - e.dmg);
      pushLog(`ENEMY(${e.tag}): -${e.dmg}`, false);

      if (battle.meHP <= 0) {
        await endBattle(false, false, false);
        return;
      }
      if (battle.turn >= TURN_LIMIT) {
        await endBattle(false, false, true);
        return;
      }

      renderBattle();
    } finally {
      battle._busy = false;
    }
  }

  function ratioNowForOverkill(){
    const Pme = playerPowerMetric();
    const Penemy = enemyPowerMetricFromStats(battle.enemyAtk, battle.enemyDef, battle.enemyMAtk, battle.enemyMDef);
    return Pme / Math.max(1, Penemy);
  }

  async function animateSkip(k){
    $("#skipLine").textContent = "";
    const showCount = Math.min(k, 18);
    for (let i=1; i<=showCount; i++){
      $("#skipLine").textContent = `+${i}`;
      await sleep(35);
    }
    if (k > showCount) {
      $("#skipLine").textContent = `+${showCount} …`;
      await sleep(120);
    }
    $("#skipLine").textContent = `+${k} level!!!`;
    await sleep(220);
  }
  function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

  async function endBattle(win, _unused, timeout){
    stopBattleLoop();
    showBattle(false);

    const enemyHpPct = battle.enemyMaxHP > 0 ? (battle.enemyHP / battle.enemyMaxHP) : 0;
    const myHpPct = battle.meMaxHP > 0 ? (battle.meHP / battle.meMaxHP) : 0;

    const title = win ? "승리" : "패배";
    const sub = timeout
      ? `턴 초과 · 적 HP ${Math.round(enemyHpPct*100)}%`
      : `적 HP ${Math.round(enemyHpPct*100)}% · 내 HP ${Math.round(myHpPct*100)}% · 턴 ${battle.turn}/${TURN_LIMIT}`;

    $("#resultTitle").textContent = title;
    $("#resultSub").textContent = sub;
    $("#overkill").style.display = "none";
    $("#skipLine").textContent = "";

    if (win) {
      S.maxLevelThisLife = Math.max(S.maxLevelThisLife, S.enemyLevel);

      if (myHpPct >= OVERKILL_HP_PCT) {
        const ratio = ratioNowForOverkill();
        let k = ratio > 1 ? Math.ceil(Math.log(ratio) / Math.log(1.1)) : 1;
        k = Math.max(1, k);

        $("#overkill").style.display = "block";
        await animateSkip(k);

        S.enemyLevel += k;
        regenEnemyForLevel();
      } else if (myHpPct >= SKIP2_HP_PCT) {
        S.enemyLevel += 2;
        regenEnemyForLevel();
      } else {
        S.enemyLevel += 1;
        regenEnemyForLevel();
      }

      S.maxLevelThisLife = Math.max(S.maxLevelThisLife, S.enemyLevel);
      save();
      render();
    }

    showResult(true);
    battle = null;
  }

  // ---------- Rebirth ----------
  function rebirthReady(){ return S.focusSecondsSinceRebirth >= 3000; }
  function doRebirth(){
    if (!rebirthReady()) { toast("환생 조건 미달 (집중 누적 50분 필요)"); return; }

    const delta = S.maxLevelThisLife / 100;
    S.c0 += delta;

    S.rebirthCount += 1;
    S.focusSecondsSinceRebirth = 0;
    S.maxLevelThisLife = 1;

    // 포인트/레벨 리셋
    S.points = 0;

    // 스탯은 유지, 비용 카운터만 초기화
    S.statBuys = 0;

    // 치명/치피는 유지 (플레이어 특권)
    // S.critChance / S.critDmgUp 유지

    S.enemyLevel = 1;
    regenEnemyForLevel();

    save();
    render();
    toast(`환생! ΔC0 +${fmt2(delta)} (C0 ${fmt2(S.c0)})`);
  }

  // ---------- UI Wiring ----------
  $("#btnSettings").addEventListener("click", () => showSettings(true));
  $("#btnSettingsClose").addEventListener("click", () => showSettings(false));

  $("#btnGrow").addEventListener("click", () => {
    if (S.isGrowing) settleGrowth();
    else startGrowth();
  });
  $("#btnSettleOnly").addEventListener("click", () => {
    if (S.isGrowing) settleGrowth();
  });

  $("#btnUpgrade").addEventListener("click", () => {
    if (S.isGrowing) return;
    showUpgrade(true);
    renderUpgrade();
  });
  $("#btnUpgradeClose").addEventListener("click", () => showUpgrade(false));

  $("#btnBattle").addEventListener("click", () => {
    if (S.isGrowing) return;
    openBattle();
  });
  $("#btnBattleExit").addEventListener("click", () => {
    stopBattleLoop();
    showBattle(false);
    battle = null;
  });

  $("#btnConfirm").addEventListener("click", () => {
    showResult(false);
    render();
  });

  $("#btnRebirth").addEventListener("click", () => {
    if (S.isGrowing) { toast("집중중에는 환생할 수 없습니다. 먼저 정산하세요."); return; }
    if (!rebirthReady()) { toast(`환생 가능까지 ${Math.ceil((3000 - S.focusSecondsSinceRebirth)/60)}분`); return; }
    const delta = S.maxLevelThisLife / 100;
    const ok = confirm(
      `환생하시겠습니까?\n\n이번 생 최고 레벨: ${S.maxLevelThisLife}\nΔC0 = ${delta.toFixed(2)}\nC0: ${S.c0.toFixed(2)} → ${(S.c0+delta).toFixed(2)}\n\n(레벨/포인트 리셋, 스탯 유지, 스탯 비용카운터만 초기화)`
    );
    if (ok) doRebirth();
  });

  $("#btnStartPhy").addEventListener("click", () => {
    if (!battle) return;
    battle.chosenMode = "phy";
    $("#modeChooser").style.display = "none";
    $("#modeFixed").style.display = "block";
    $("#btnStep").disabled = false;
    pushLog(`START: PHY 고정`, true);
    renderBattle();
    startBattleLoop();
  });
  $("#btnStartMag").addEventListener("click", () => {
    if (!battle) return;
    battle.chosenMode = "mag";
    $("#modeChooser").style.display = "none";
    $("#modeFixed").style.display = "block";
    $("#btnStep").disabled = false;
    pushLog(`START: MAG 고정`, true);
    renderBattle();
    startBattleLoop();
  });
  $("#btnStep").addEventListener("click", () => {
    if (!battle || !battle.chosenMode) return;
    doTurn(battle.chosenMode);
  });

  // ---------- Settings ----------
  function setDisplayMode(mode){
    S.ui = S.ui || { display:"ON", refreshSec:1 };
    S.ui.display = mode;
    save();
    render();
    if ($("#settingsOverlay").style.display === "block") renderSettings();
  }
  function setRefreshSec(sec){
    S.ui = S.ui || { display:"ON", refreshSec:1 };
    S.ui.refreshSec = sec;
    save();
    scheduleGrowthUiTimer();
    if ($("#settingsOverlay").style.display === "block") renderSettings();
  }
  $("#optDisplayOn").addEventListener("click", () => setDisplayMode("ON"));
  $("#optDisplayOff").addEventListener("click", () => setDisplayMode("OFF"));
  $("#optT1").addEventListener("click", () => setRefreshSec(1));
  $("#optT60").addEventListener("click", () => setRefreshSec(60));
  $("#optT300").addEventListener("click", () => setRefreshSec(300));

  function renderSettings(){
    const ui = S.ui || { display:"ON", refreshSec:1 };
    $("#vDisplayMode").textContent = ui.display;
    $("#vRefresh").textContent = (ui.refreshSec === 1) ? "1초" : (ui.refreshSec === 60 ? "1분" : "5분");
  }

  // ---------- Upgrade UI ----------
  function makeBtn(text, onClick, enabled=true){
    const b = document.createElement("button");
    b.className = "mini";
    b.textContent = text;
    b.disabled = !enabled;
    b.addEventListener("click", onClick);
    return b;
  }

  function renderUpgrade(){
    $("#uPoints").textContent = fmt(S.points);

    $("#vATK").textContent = S.atk;
    $("#vDEF").textContent = S.def;
    $("#vMATK").textContent = S.matk;
    $("#vMDEF").textContent = S.mdef;

    $("#vCrit").textContent = `${S.critChance}%`;
    $("#vCritDmg").textContent = `+${critBonusPct()}%`;

    const canReb = rebirthReady();
    $("#vRebirth").textContent = canReb
      ? `가능 (최고Lv ${S.maxLevelThisLife}, ΔC0 ${(S.maxLevelThisLife/100).toFixed(2)})`
      : `불가 (남은 ${Math.ceil((3000 - S.focusSecondsSinceRebirth)/60)}분)`;

    renderStatButtons("atk", "#bATK");
    renderStatButtons("def", "#bDEF");
    renderStatButtons("matk", "#bMATK");
    renderStatButtons("mdef", "#bMDEF");
    renderCritButtons();
    renderCritDmgButtons();
  }

  function renderStatButtons(key, containerSel){
    const el = $(containerSel);
    el.innerHTML = "";

    const v = S[key];
    const bigEnabled = v >= 100; // +100/MAX 활성화 조건(요구사항)

    const cost1 = statCostForN(S.statBuys, 1);
    const cost10 = statCostForN(S.statBuys, 10);
    const cost100 = statCostForN(S.statBuys, 100);

    const can1 = cost1 <= S.points + 1e-9;
    const can10 = cost10 <= S.points + 1e-9;
    const can100 = bigEnabled && (cost100 <= S.points + 1e-9);

    const nMax = maxAffordableStatN(S.points);
    const canMax = bigEnabled && nMax > 0;

    const add = (n) => {
      const ok = applyStatUpgrade(key, n);
      if (!ok) toast("포인트 부족");
      renderUpgrade();
    };

    el.appendChild(makeBtn("+1", () => add(1), can1));
    el.appendChild(makeBtn("+10", () => add(10), can10));
    el.appendChild(makeBtn("+100", () => add(100), can100));
    el.appendChild(makeBtn("MAX(≤100)", () => {
      if (nMax <= 0) { toast("포인트 부족"); return; }
      applyStatUpgrade(key, nMax);
      renderUpgrade();
    }, canMax));
  }

  function renderCritButtons(){
    const el = $("#bCrit");
    el.innerHTML = "";
    const canInc = S.critChance < 90;

    const can1 = canInc && (critChanceCost(S.critChance) <= S.points + 1e-9);

    let cost5 = 0, can5 = false;
    if (canInc) {
      const realDelta = Math.min(5, 90 - S.critChance);
      for (let i=0;i<realDelta;i++) cost5 += critChanceCost(S.critChance + i);
      can5 = cost5 <= S.points + 1e-9;
    }

    el.appendChild(makeBtn("+1", () => {
      const ok = applyCritChance(1);
      if (!ok) toast("포인트 부족");
      renderUpgrade();
    }, can1));

    el.appendChild(makeBtn("+5", () => {
      const ok = applyCritChance(5);
      if (!ok) toast("포인트 부족");
      renderUpgrade();
    }, can5));
  }

  function renderCritDmgButtons(){
    const el = $("#bCritDmg");
    el.innerHTML = "";

    const can1 = critDmgCost(S.critDmgUp) <= S.points + 1e-9;

    let cost5 = 0;
    for (let i=0;i<5;i++) cost5 += critDmgCost(S.critDmgUp + i);
    const can5 = cost5 <= S.points + 1e-9;

    el.appendChild(makeBtn("+1", () => {
      const ok = applyCritDmgUp(1);
      if (!ok) toast("포인트 부족");
      renderUpgrade();
    }, can1));

    el.appendChild(makeBtn("+5", () => {
      const ok = applyCritDmgUp(5);
      if (!ok) toast("포인트 부족");
      renderUpgrade();
    }, can5));
  }

  // ---------- OFF Focus + Stealth Preview ----------
  let stealthUntil = 0;
  const STEALTH_MS = 1500;

  function triggerStealthPeek(){
    if (!S.isGrowing) return;
    const ui = S.ui || { display:"ON", refreshSec:1 };
    if (ui.display !== "OFF") return;

    stealthUntil = now() + STEALTH_MS;
    render();
    clearTimeout(triggerStealthPeek._t);
    triggerStealthPeek._t = setTimeout(() => render(), STEALTH_MS + 10);
  }

  $("#appRoot").addEventListener("click", (e) => {
    if (e.target && (e.target.closest("#btnSettings") || e.target.closest("button") || e.target.closest("#settingsOverlay"))) return;
    triggerStealthPeek();
  });

  function applyOffFocusUi(on){
    const app = $("#appRoot");
    const bottomNormal = $("#btnRowNormal");
    const bottomSettle = $("#btnRowSettleOnly");
    const elapsedBox = $("#elapsedOnlyBox");

    if (on) {
      app.classList.add("offFocus");
      bottomNormal.style.display = "none";
      bottomSettle.style.display = "flex";
      elapsedBox.style.display = "block";
    } else {
      app.classList.remove("offFocus");
      bottomNormal.style.display = "flex";
      bottomSettle.style.display = "none";
      elapsedBox.style.display = "none";
      $("#stealthPeek").style.display = "none";
      $("#stealthPeek").textContent = "";
    }
  }

  // ---------- Render ----------
  function render(){
    const ui = S.ui || { display:"ON", refreshSec:1 };
    const live = $("#liveGain");

    const mid = isMidBossLevel(S.enemyLevel) ? " · MID BOSS" : "";
    $("#topLeft").textContent = `Enemy Lv ${S.enemyLevel} · ${S.enemyType}${mid}`;
    $("#topRight").textContent = `C0 ${fmt2(S.c0)} | C ${fmt2(currentC())}`;

    if (S.isGrowing) {
      const { tSec, eff, gain } = calcGrowthPreview();

      if (ui.display === "OFF") {
        applyOffFocusUi(true);

        $("#elapsedOnly").textContent = fmtTime(tSec);
        $("#elapsedSub").textContent = "집중 중 (탭하면 잠깐 표시)";

        const peekEl = $("#stealthPeek");
        const showPeek = now() < stealthUntil;
        if (showPeek) {
          const total = S.points + gain;
          peekEl.style.display = "block";
          peekEl.textContent =
            `현재 포인트: ${fmt(total)}\n예상 증가: +${fmt(gain)} (효율 ${eff}%)`;
        } else {
          peekEl.style.display = "none";
          peekEl.textContent = "";
        }
      } else {
        applyOffFocusUi(false);

        $("#points").textContent = fmt(S.points + gain);
        live.style.display = "block";
        live.textContent = `경과 ${fmtTime(tSec)} · +${fmt(gain)} (효율 ${eff}%)`;

        $("#status").textContent = "집중";
        $("#btnGrow").textContent = "정산하기";
        $("#btnUpgrade").disabled = true;
        $("#btnBattle").disabled = true;
      }
    } else {
      applyOffFocusUi(false);

      $("#points").textContent = fmt(S.points);
      live.style.display = "none";
      live.textContent = "";

      $("#status").textContent = "대기";
      $("#btnGrow").textContent = "집중하기";
      $("#btnUpgrade").disabled = false;
      $("#btnBattle").disabled = false;
    }

    const mins = Math.floor(S.focusSecondsSinceRebirth / 60);
    $("#rebirthInfo").textContent =
      `환생: 누적 ${mins}분 / 50분 · 이번 생 최고 Lv ${S.maxLevelThisLife} · ΔC0 ${(S.maxLevelThisLife/100).toFixed(2)}`;

    if ($("#upgradeOverlay").style.display === "block") renderUpgrade();
  }

  function renderBattle(){
    if (!battle) return;

    $("#turnLimit").textContent = TURN_LIMIT;

    const mid = battle.enemyIsMidBoss ? " · MID BOSS" : "";
    $("#battleTop").textContent = `Enemy Lv ${S.enemyLevel} · ${battle.enemyType}${mid}`;

    // 내/적 스탯 동시 표기
    $("#statsLine").textContent =
      `MY: ATK ${S.atk} DEF ${S.def} MATK ${S.matk} MDEF ${S.mdef}\n` +
      `E : ATK ${battle.enemyAtk} DEF ${battle.enemyDef} MATK ${battle.enemyMAtk} MDEF ${battle.enemyMDef}`;

    const enemyHpPct = Math.max(0, Math.min(1, battle.enemyHP / Math.max(1, battle.enemyMaxHP)));
    const meHpPct = Math.max(0, Math.min(1, battle.meHP / Math.max(1, battle.meMaxHP)));
    $("#enemyHPpct").textContent = `${Math.round(enemyHpPct * 100)}%`;
    $("#meHPpct").textContent = `${Math.round(meHpPct * 100)}%`;

    $("#turn").textContent = battle.turn;

    if (battle.chosenMode) {
      const recommend = (battle.enemyType === "MAG") ? "물리" : "마법";
      $("#modeFixed").textContent =
        `이번 전투: ${battle.chosenMode === "phy" ? "물리" : "마법"} 고정 · 추천: ${recommend}`;
    }

    const logEl = $("#log");
    if (battle.log.length === 0) logEl.textContent = "";
    else {
      logEl.innerHTML = battle.log.map(x => {
        const cls = x.highlight ? "crit" : "";
        return `<div class="${cls}">${escapeHtml(x.line)}</div>`;
      }).join("");
      logEl.scrollTop = logEl.scrollHeight;
    }
  }

  // ---------- Growth UI Timer ----------
  let growthUiTimer = null;
  function scheduleGrowthUiTimer(){
    const ui = S.ui || { display:"ON", refreshSec:1 };
    if (growthUiTimer) { clearInterval(growthUiTimer); growthUiTimer = null; }
    const ms = Math.max(1000, ui.refreshSec * 1000);

    growthUiTimer = setInterval(() => {
      if (!S.isGrowing) return;
      render();
    }, ms);
  }

  // ---------- Persistence ----------
  function save(){
    try { localStorage.setItem(KEY, JSON.stringify(S)); } catch(e) {}
  }
  function load(){
    try {
      const raw = localStorage.getItem(KEY);
      if (!raw) {
        const s = structuredClone(DEFAULT);
        s.enemyLevel = 1;
        s.enemyAtk = 0; s.enemyDef = 0;
        s.enemyMAtk = 0; s.enemyMDef = 0;
        return s;
      }
      const loaded = Object.assign(structuredClone(DEFAULT), JSON.parse(raw));
      loaded.ui = Object.assign({ display:"ON", refreshSec:1 }, loaded.ui || {});
      if (loaded.statBuys == null) loaded.statBuys = 0;

      // 구버전 호환: piercePct가 있어도 그냥 무시 (삭제됨)
      return loaded;
    } catch(e) {
      return structuredClone(DEFAULT);
    }
  }

  // ---------- Boot ----------
  regenEnemyForLevel();
  render();
  scheduleGrowthUiTimer();

  // Optional: keep screen awake (if supported)
  let wakeLock = null;
  async function tryWakeLock(){
    try {
      if ("wakeLock" in navigator && !wakeLock) {
        wakeLock = await navigator.wakeLock.request("screen");
      }
    } catch(e) {}
  }
  document.addEventListener("visibilitychange", () => {
    if (!document.hidden) tryWakeLock();
  });
  tryWakeLock();
})();
</script>
</body>
</html>
