<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Focus Idle v5</title>
  <style>
    :root { --bg:#000; --fg:#fff; --muted:rgba(255,255,255,.65); --dim:rgba(255,255,255,.25); }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--fg);
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,AppleSDGothicNeo,Helvetica,Arial,sans-serif; }
    .app { height:100%; display:flex; flex-direction:column; }
    .top { padding:14px 16px 8px; font-size:12px; color:var(--muted); display:flex; justify-content:space-between; gap:10px; }
    .center { flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center; padding:16px; }
    .label { font-size:12px; color:var(--muted); letter-spacing:.12em; }
    .points { font-size:56px; font-weight:700; margin:10px 0 6px; }
    .status { margin-top:10px; font-size:14px; color:var(--muted); line-height:1.6; }
    .bottom { padding:10px 12px 16px; position:sticky; bottom:0;
      background:linear-gradient(to top, rgba(0,0,0,.95), rgba(0,0,0,.65), rgba(0,0,0,0)); }
    .btnrow { display:flex; gap:10px; }
    button {
      flex:1; border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.06); color:var(--fg);
      padding:14px 10px; border-radius:12px; font-size:14px; cursor:pointer;
    }
    button:disabled { opacity:.35; cursor:not-allowed; }

    .overlay, .modal { position:fixed; inset:0; background:rgba(0,0,0,.92); display:none; z-index:20; }
    .panel { max-width:520px; margin:0 auto; height:100%; display:flex; flex-direction:column; }
    .panelTop { padding:14px 16px; display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid rgba(255,255,255,.14); }
    .panelTop h2 { margin:0; font-size:14px; font-weight:700; letter-spacing:.06em; color:var(--fg); }
    .panelTop button { flex:0 0 auto; padding:10px 12px; border-radius:10px; }
    .panelBody { padding:14px 16px; overflow:auto; }
    .row { padding:12px 0; border-bottom:1px solid rgba(255,255,255,.10); }
    .rowHead { display:flex; justify-content:space-between; align-items:baseline; gap:10px; }
    .rowHead .name { font-size:13px; color:var(--muted); }
    .rowHead .val { font-size:18px; font-weight:700; }
    .rowBtns { display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
    .mini { flex:0 0 auto; padding:10px 12px; border-radius:10px; font-size:13px; }
    .hint { margin:8px 0 0; color:var(--dim); font-size:12px; }

    .toast {
      position:fixed; left:50%; bottom:92px; transform:translateX(-50%);
      background:rgba(255,255,255,.10); border:1px solid rgba(255,255,255,.18);
      color:var(--fg); padding:10px 12px; border-radius:12px; font-size:13px;
      display:none; z-index:50;
      max-width:min(520px, calc(100% - 24px));
    }

    /* Battle */
    .battleBox { padding:16px; }
    .bigline { font-size:14px; font-weight:700; margin:8px 0 12px; line-height:1.55; }
    .hpbox { display:flex; justify-content:space-between; gap:12px; color:var(--muted); font-size:13px; }
    .hpn { font-size:20px; color:var(--fg); font-weight:800; margin-top:6px; }
    .log {
      margin-top:14px; color:var(--muted); font-size:13px; line-height:1.7;
      height:260px; overflow:auto;
      border:1px solid rgba(255,255,255,.10); border-radius:12px;
      padding:10px 12px;
    }
    .hl { color:var(--fg); }
    .smallTop { color:var(--muted); font-size:12px; }
    .resultCenter { height:100%; display:flex; flex-direction:column; justify-content:center; align-items:center; text-align:center; padding:18px; gap:10px; }
    .resultTitle { font-size:28px; font-weight:800; }
    .resultSub { color:var(--muted); font-size:14px; line-height:1.6; }
    .overkill { margin-top:8px; font-weight:800; letter-spacing:.08em; }
    .skipLine { color:var(--muted); font-size:14px; min-height:22px; }
    .confirmBtn { width:min(320px, 92%); }
  </style>
</head>
<body>
<div class="app">
  <div class="top">
    <div id="topLeft">Enemy Lv 1</div>
    <div id="topRight">C0 5.00 | C 5.00</div>
  </div>

  <div class="center">
    <div class="label">POINTS</div>
    <div class="points" id="points">0</div>
    <div class="status" id="liveGain" style="margin-top:6px; font-size:13px; color:rgba(255,255,255,.55); display:none;"></div>
    <div class="status" id="status"></div>
    <div class="status" id="rebirthInfo" style="margin-top:10px; color:rgba(255,255,255,.35); font-size:12px;"></div>
  </div>

  <div class="bottom">
    <div class="btnrow">
      <button id="btnUpgrade">업그레이드</button>
      <button id="btnBattle">전투</button>
      <button id="btnGrow">집중하기</button>
    </div>
  </div>
</div>

<!-- Upgrade -->
<div class="overlay" id="upgradeOverlay" aria-hidden="true">
  <div class="panel">
    <div class="panelTop">
      <h2>업그레이드</h2>
      <button id="btnUpgradeClose" class="mini">닫기</button>
    </div>
    <div class="panelBody">
      <div class="row">
        <div class="rowHead">
          <div class="name">포인트</div>
          <div class="val" id="uPoints">0</div>
        </div>
        <div class="hint" id="uCostHint"></div>
      </div>

      <div class="row">
        <div class="rowHead"><div class="name">ATK</div><div class="val" id="vATK">0</div></div>
        <div class="rowBtns" id="bATK"></div>
      </div>

      <div class="row">
        <div class="rowHead"><div class="name">DEF</div><div class="val" id="vDEF">0</div></div>
        <div class="rowBtns" id="bDEF"></div>
      </div>

      <div class="row">
        <div class="rowHead"><div class="name">MATK</div><div class="val" id="vMATK">0</div></div>
        <div class="rowBtns" id="bMATK"></div>
      </div>

      <div class="row">
        <div class="rowHead"><div class="name">MDEF</div><div class="val" id="vMDEF">0</div></div>
        <div class="rowBtns" id="bMDEF"></div>
      </div>

      <div class="row">
        <div class="rowHead"><div class="name">CRIT%</div><div class="val" id="vCrit">0%</div></div>
        <div class="rowBtns" id="bCrit"></div>
        <div class="hint">플레이어 공격에만 적용 · 비용 10×2^현재%</div>
      </div>

      <div class="row">
        <div class="rowHead"><div class="name">PEN%</div><div class="val" id="vPen">0%</div></div>
        <div class="rowBtns" id="bPen"></div>
        <div class="hint">방어력에 % 관통 적용 · 비용 10×2^현재%</div>
      </div>

      <div class="row">
        <div class="rowHead"><div class="name">환생</div><div class="val" id="vRebirth">-</div></div>
        <div class="rowBtns">
          <button id="btnRebirth" class="mini">환생</button>
        </div>
        <div class="hint">
          조건: 환생 이후 누적 집중 50분(3000초)<br/>
          효과: 레벨 1 리셋 · 스탯 승계 · 통합스탯 요구량 초기화 · 포인트 0 · C0 10% 증가
        </div>
      </div>

      <!-- SAVE / EXPORT / IMPORT -->
      <div class="row">
        <div class="rowHead"><div class="name">세이브</div><div class="val">복사/붙여넣기</div></div>
        <div class="rowBtns">
          <button id="btnExport" class="mini">내보내기(복사)</button>
          <button id="btnImport" class="mini">가져오기(붙여넣기)</button>
          <button id="btnImportClip" class="mini">클립보드에서 가져오기</button>
        </div>
        <div class="hint">기기 변경: 내보내기 → 다른 기기에서 가져오기</div>
      </div>

      <div class="row">
        <div class="hint">Tip: 탭이 꺼지거나 앱 전환 시 자동 정산 후 집중 종료됩니다.</div>
      </div>
    </div>
  </div>
</div>

<!-- Battle -->
<div class="overlay" id="battleOverlay" aria-hidden="true">
  <div class="panel">
    <div class="panelTop">
      <h2>전투</h2>
      <button id="btnBattleExit" class="mini">나가기</button>
    </div>
    <div class="panelBody battleBox">
      <div class="smallTop" id="battleTop">Enemy Lv 1</div>

      <div class="bigline" id="statLineMe">-</div>
      <div class="bigline" id="statLineEnemy">-</div>

      <div class="hpbox">
        <div style="flex:1;">
          <div>적 HP</div>
          <div class="hpn"><span id="enemyHPpct">100</span>%</div>
        </div>
        <div style="flex:1;">
          <div>내 HP</div>
          <div class="hpn"><span id="meHPpct">100</span>%</div>
        </div>
      </div>

      <div class="status" style="margin-top:10px;">
        TURN <span id="turn">0</span>/<span id="turnLimit">30</span>
      </div>

      <div id="modeChooser" style="margin-top:14px; display:flex; gap:10px;">
        <button id="btnStartPhy">물리로 도전</button>
        <button id="btnStartMag">마법으로 도전</button>
      </div>
      <div class="status" id="modeFixed" style="margin-top:10px; display:none;"></div>

      <div class="log" id="log"></div>
      <div class="hint" style="margin-top:10px;">자동 진행: 0.5초에 1턴</div>
    </div>
  </div>
</div>

<!-- Result -->
<div class="modal" id="resultModal" aria-hidden="true">
  <div class="resultCenter">
    <div class="resultTitle" id="resultTitle">승리</div>
    <div class="resultSub" id="resultSub">-</div>
    <div class="overkill" id="overkill" style="display:none;">OVERKILL!</div>
    <div class="skipLine" id="skipLine"></div>
    <button id="btnConfirm" class="confirmBtn">확인</button>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
(() => {
  /* ==========================
     IMPORTANT: v4 저장 유지
     ========================== */
  const KEY = "focus_idle_v4"; // v4 KEY 유지 (데이터 안 날리기)
  const SAVE_VER = 2;

  /* ---------- Utilities ---------- */
  const now = () => Date.now();
  function $(sel){ return document.querySelector(sel); }
  function pad2(n){ return String(n).padStart(2,"0"); }
  function fmtTime(sec){
    const m = Math.floor(sec/60);
    const s = sec%60;
    return `${pad2(m)}:${pad2(s)}`;
  }
  function toast(msg) {
    const el = $("#toast");
    el.textContent = msg;
    el.style.display = "block";
    clearTimeout(toast._t);
    toast._t = setTimeout(() => el.style.display = "none", 950);
  }

  // 1.23e34 표기
  function fmtSci(n){
    if (!Number.isFinite(n)) return String(n);
    const abs = Math.abs(n);
    if (abs < 1000000) return Math.floor(n).toLocaleString("en-US");
    const e = Math.floor(Math.log10(abs));
    const m = n / Math.pow(10, e);
    return `${m.toFixed(2)}e${e}`;
  }
  function fmt2(n){
    if (!Number.isFinite(n)) return String(n);
    return (Math.round(n*100)/100).toFixed(2);
  }

  /* ---------- Save Encode/Decode (copy/paste) ---------- */
  function encodeSave(obj){
    const payload = { v: SAVE_VER, t: Date.now(), s: obj };
    const json = JSON.stringify(payload);
    const b64 = btoa(unescape(encodeURIComponent(json)));
    return `FI${SAVE_VER}:${b64}`;
  }
  function decodeSave(str){
    const trimmed = String(str || "").trim();
    const m = trimmed.match(/^FI(\d+):(.+)$/);
    if (!m) throw new Error("형식이 올바르지 않음");
    const b64 = m[2];
    const json = decodeURIComponent(escape(atob(b64)));
    const payload = JSON.parse(json);
    if (!payload || typeof payload !== "object" || !payload.s) throw new Error("데이터 손상");
    return payload.s;
  }
  async function copyToClipboard(text){
    try {
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(text);
        return true;
      }
    } catch(e) {}
    const ta = document.createElement("textarea");
    ta.value = text;
    ta.style.position = "fixed";
    ta.style.left = "-9999px";
    document.body.appendChild(ta);
    ta.select();
    const ok = document.execCommand("copy");
    ta.remove();
    return ok;
  }
  async function readFromClipboard(){
    if (navigator.clipboard && window.isSecureContext) return await navigator.clipboard.readText();
    throw new Error("클립보드 읽기 미지원");
  }

  /* ---------- Core State ---------- */
  const DEFAULT = {
    points: 0,

    // player stats
    atk: 5, def: 5, matk: 5, mdef: 5,

    // meta upgrades
    critChance: 0, // %
    penPct: 0,     // %

    // integrated stat cost tracker (THIS LIFE ONLY, reset on rebirth)
    bonusSpentThisLife: 0,

    // enemy progression
    enemyLevel: 1,
    enemyBasePower: 30,
    enemyType: "PHY", // "PHY" | "MAG"
    enemyAtk: 10, enemyDef: 10, enemyMAtk: 5, enemyMDef: 5,

    // growth
    isGrowing: false,
    growStartAt: 0,

    // rebirth
    c0: 5.0,
    maxLevelThisLife: 1,
    focusSecondsSinceRebirth: 0,
    rebirthCount: 0
  };

  let S = loadMerged();

  /* ---------- Derived ---------- */
  function enemyPowerForLevel(level){
    // enemy power grows 10% per level
    return Math.floor(S.enemyBasePower * Math.pow(1.1, level - 1));
  }
  function currentC(){
    // C(L) = C0 + floor((Lv-1)/3)
    return S.c0 + Math.floor((S.enemyLevel - 1) / 3);
  }
  function efficiencyPct(tSec){
    // 유지: 80% 티어 포함
    if (tSec >= 300) return 100;
    if (tSec >= 180) return 80;
    if (tSec >= 120) return 60;
    if (tSec >= 60)  return 40;
    return 20;
  }

  function playerMaxHP(){
    return (S.atk + S.def + S.matk + S.mdef) * 5;
  }

  /* ---------- Enemy generation ---------- */
  function regenEnemyForLevel(){
    const power = enemyPowerForLevel(S.enemyLevel);
    S.enemyType = (Math.random() < 0.5) ? "PHY" : "MAG";

    // split total power into PHY vs MAG biased
    const phyPower = Math.max(1, Math.floor(power * (S.enemyType === "PHY" ? 0.8 : 0.2)));
    const magPower = Math.max(1, Math.floor(power * (S.enemyType === "MAG" ? 0.8 : 0.2)));

    // split inside phyPower -> atk/def
    const r1 = 0.35 + Math.random() * 0.30;
    S.enemyAtk = Math.max(1, Math.round(phyPower * r1));
    S.enemyDef = Math.max(0, phyPower - S.enemyAtk);

    // split inside magPower -> matk/mdef
    const r2 = 0.35 + Math.random() * 0.30;
    S.enemyMAtk = Math.max(1, Math.round(magPower * r2));
    S.enemyMDef = Math.max(0, magPower - S.enemyMAtk);

    save();
  }
  if (!S.enemyType || S.enemyMAtk == null || S.enemyMDef == null) regenEnemyForLevel();

  /* ---------- Growth ---------- */
  function startGrowth(){
    if (S.isGrowing) return;
    S.isGrowing = true;
    S.growStartAt = now();
    save();
    render();
  }
  function settleGrowth(){
    if (!S.isGrowing) return;
    const tSec = Math.max(0, Math.floor((now() - S.growStartAt) / 1000));
    const E = efficiencyPct(tSec) / 100;
    const C = currentC();
    const gain = Math.floor(tSec * C * E);

    S.points += gain;
    S.focusSecondsSinceRebirth += tSec;

    S.isGrowing = false;
    S.growStartAt = 0;
    save();
    render();
    if (tSec > 0) toast(`정산 +${fmtSci(gain)} (${tSec}s, ${Math.round(E*100)}%)`);
  }
  document.addEventListener("visibilitychange", () => { if (document.hidden) settleGrowth(); });
  window.addEventListener("pagehide", () => settleGrowth());

  /* ============================================================
     Upgrade Cost Rules (v5)
     - Integrated stats: cost per +1 = 10 * 2^(bonusSpentThisLife + i)
       (rebirth resets bonusSpentThisLife only)
     - Crit/Pen: cost per +1 = 10 * 2^(current value)
       (rebirth does NOT reset)
     ============================================================ */
  function sumPow2(a, n){
    // sum_{i=0..n-1} 2^(a+i) = 2^a * (2^n - 1)
    return Math.pow(2, a) * (Math.pow(2, n) - 1);
  }
  function bonusCost(n){
    return 10 * sumPow2(S.bonusSpentThisLife, n);
  }
  function applyBonus(statKey, n){
    if (n <= 0) return false;
    const cost = bonusCost(n);
    if (cost > S.points + 1e-9) return false;
    S.points -= cost;
    S[statKey] += n;
    S.bonusSpentThisLife += n;
    save(); render();
    return true;
  }

  function expCost(base, n){
    // cost for +n when each step is 10*2^(base+i)
    return 10 * sumPow2(base, n);
  }
  function applyCrit(n){
    if (n <= 0) return false;
    const cost = expCost(S.critChance, n);
    if (cost > S.points + 1e-9) return false;
    S.points -= cost;
    S.critChance = Math.min(90, S.critChance + n);
    save(); render();
    return true;
  }
  function applyPen(n){
    if (n <= 0) return false;
    const cost = expCost(S.penPct, n);
    if (cost > S.points + 1e-9) return false;
    S.points -= cost;
    S.penPct = Math.min(90, S.penPct + n);
    save(); render();
    return true;
  }

  /* ---------- Battle ---------- */
  const TURN_LIMIT = 30;
  const LOG_LIMIT = 80;
  const TURN_MS = 500; // 0.5초

  let battle = null;
  let battleTimer = null;

  function enemyMaxHPFromStats(ea, ed, ema, emd){
    return (ea + ed + ema + emd) * 5;
  }

  function showBattle(on){
    $("#battleOverlay").style.display = on ? "block" : "none";
    $("#battleOverlay").setAttribute("aria-hidden", on ? "false" : "true");
  }
  function showUpgrade(on){
    $("#upgradeOverlay").style.display = on ? "block" : "none";
    $("#upgradeOverlay").setAttribute("aria-hidden", on ? "false" : "true");
  }
  function showResult(on){
    $("#resultModal").style.display = on ? "block" : "none";
  }

  function stopBattleLoop(){
    if (battleTimer) { clearInterval(battleTimer); battleTimer = null; }
  }
  function startBattleLoop(){
    stopBattleLoop();
    battleTimer = setInterval(() => {
      if (!battle) return;
      if ($("#battleOverlay").style.display !== "block") return;
      if (!battle.chosenMode) return;
      doTurn(battle.chosenMode);
    }, TURN_MS);
  }

  function openBattle(){
    if (S.isGrowing) return;

    const meMax = playerMaxHP();
    const enMax = enemyMaxHPFromStats(S.enemyAtk, S.enemyDef, S.enemyMAtk, S.enemyMDef);

    battle = {
      chosenMode: null, // "phy" | "mag"
      enemyType: S.enemyType,
      enemyAtk: S.enemyAtk,
      enemyDef: S.enemyDef,
      enemyMAtk: S.enemyMAtk,
      enemyMDef: S.enemyMDef,
      enemyMaxHP: enMax,
      enemyHP: enMax,
      meMaxHP: meMax,
      meHP: meMax,
      turn: 0,
      log: [],
      _busy: false
    };

    $("#modeChooser").style.display = "flex";
    $("#modeFixed").style.display = "none";

    showBattle(true);
    renderBattle();
  }

  // NEW: dmg = attack - (def*(1-pen%))
  // crit applies to player only; crit multiplier 1.5
  function effDef(rawDef){
    const p = Math.max(0, Math.min(90, S.penPct)) / 100;
    return Math.floor(rawDef * (1 - p));
  }
  function playerDamage(att, def){
    let d = Math.max(1, att - effDef(def));
    const isCrit = (Math.random()*100) < S.critChance;
    if (isCrit) d = Math.floor(d * 1.5);
    return { d, isCrit };
  }
  function enemyDamage(att, def){
    // enemy no crit/pen
    return Math.max(1, att - def);
  }

  function pushLog(line, highlight=false){
    battle.log.push({ line, highlight });
    if (battle.log.length > LOG_LIMIT) battle.log.shift();
  }

  async function doTurn(mode){
    if (!battle) return;
    if (battle._busy) return;
    battle._busy = true;

    try {
      battle.turn += 1;

      // Player attacks
      if (mode === "phy") {
        const { d, isCrit } = playerDamage(S.atk, battle.enemyDef);
        battle.enemyHP = Math.max(0, battle.enemyHP - d);
        pushLog(`${isCrit ? "CRIT " : ""}YOU(PHY): -${fmtSci(d)}`, isCrit);
      } else {
        const { d, isCrit } = playerDamage(S.matk, battle.enemyMDef);
        battle.enemyHP = Math.max(0, battle.enemyHP - d);
        pushLog(`${isCrit ? "CRIT " : ""}YOU(MAG): -${fmtSci(d)}`, isCrit);
      }

      if (battle.enemyHP <= 0) {
        const oneTurnKill = (battle.turn === 1);
        await endBattle(true, oneTurnKill, false);
        return;
      }

      // Enemy counter: based on its type
      if (battle.enemyType === "PHY") {
        const d = enemyDamage(battle.enemyAtk, S.def);
        battle.meHP = Math.max(0, battle.meHP - d);
        pushLog(`ENEMY(PHY): -${fmtSci(d)}`, false);
      } else {
        const d = enemyDamage(battle.enemyMAtk, S.mdef);
        battle.meHP = Math.max(0, battle.meHP - d);
        pushLog(`ENEMY(MAG): -${fmtSci(d)}`, false);
      }

      if (battle.meHP <= 0) {
        await endBattle(false, false, false);
        return;
      }
      if (battle.turn >= TURN_LIMIT) {
        await endBattle(false, false, true);
        return;
      }

      renderBattle();
    } finally {
      battle._busy = false;
    }
  }

  function ratioNowForOverkill(){
    // 비교는 간단히 합산 스탯으로 (10% 레벨 성장과 맞추기 쉬움)
    const me = (S.atk + S.def + S.matk + S.mdef);
    const en = (battle.enemyAtk + battle.enemyDef + battle.enemyMAtk + battle.enemyMDef);
    return me / Math.max(1, en);
  }

  async function endBattle(win, oneTurnKill, timeout){
    stopBattleLoop();
    showBattle(false);

    if (win) S.maxLevelThisLife = Math.max(S.maxLevelThisLife, S.enemyLevel);

    $("#resultTitle").textContent = win ? "승리" : "패배";
    $("#resultSub").textContent = timeout
      ? `턴 초과 · 적 HP ${Math.round((battle.enemyHP / battle.enemyMaxHP)*100)}%`
      : `적 HP ${Math.round((battle.enemyHP / battle.enemyMaxHP)*100)}% · 턴 ${battle.turn}/${TURN_LIMIT}`;
    $("#overkill").style.display = "none";
    $("#skipLine").textContent = "";

    if (win) {
      if (oneTurnKill) {
        const ratio = ratioNowForOverkill();
        const k = ratio > 1 ? Math.ceil(Math.log(ratio) / Math.log(1.1)) : 0;
        if (k > 0) {
          $("#overkill").style.display = "block";
          await animateSkip(k);
          S.enemyLevel += k;
          regenEnemyForLevel();
        } else {
          S.enemyLevel += 1;
          regenEnemyForLevel();
        }
      } else {
        S.enemyLevel += 1;
        regenEnemyForLevel();
      }
      S.maxLevelThisLife = Math.max(S.maxLevelThisLife, S.enemyLevel);
      save();
      render();
    }

    showResult(true);
    battle = null;
  }

  async function animateSkip(k){
    $("#skipLine").textContent = "";
    const showCount = Math.min(k, 18);
    for (let i=1; i<=showCount; i++){
      $("#skipLine").textContent = `+${i}`;
      await sleep(35);
    }
    if (k > showCount) {
      $("#skipLine").textContent = `+${showCount} …`;
      await sleep(120);
    }
    $("#skipLine").textContent = `+${k} level!!!`;
    await sleep(220);
  }
  function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

  /* ---------- Rebirth ---------- */
  function rebirthReady(){ return S.focusSecondsSinceRebirth >= 3000; }
  function doRebirth(){
    if (!rebirthReady()) { toast("환생 조건 미달 (누적 집중 50분 필요)"); return; }

    // C0 10% 증가 (요청 반영)
    S.c0 = S.c0 * 1.10;

    // reset run vars
    S.rebirthCount += 1;
    S.focusSecondsSinceRebirth = 0;
    S.maxLevelThisLife = 1;

    // level reset
    S.enemyLevel = 1;

    // points reset (요청: 포인트 승계 의미 없음)
    S.points = 0;

    // IMPORTANT: stats are preserved (atk/def/matk/mdef), crit/pen preserved
    // integrated stat costs reset only
    S.bonusSpentThisLife = 0;

    regenEnemyForLevel();
    save();
    render();
    toast(`환생! C0 → ${fmt2(S.c0)}`);
  }

  /* ---------- UI Wiring ---------- */
  $("#btnGrow").addEventListener("click", () => {
    if (S.isGrowing) settleGrowth();
    else startGrowth();
  });

  $("#btnUpgrade").addEventListener("click", () => {
    if (S.isGrowing) return;
    showUpgrade(true);
    renderUpgrade();
  });
  $("#btnUpgradeClose").addEventListener("click", () => showUpgrade(false));

  $("#btnBattle").addEventListener("click", () => {
    if (S.isGrowing) return;
    openBattle();
  });
  $("#btnBattleExit").addEventListener("click", () => {
    stopBattleLoop();
    showBattle(false);
    battle = null;
  });

  $("#btnConfirm").addEventListener("click", () => {
    showResult(false);
    render();
  });

  $("#btnRebirth").addEventListener("click", () => {
    if (S.isGrowing) { toast("집중 중에는 환생 불가 (정산 후 가능)"); return; }
    if (!rebirthReady()) {
      toast(`환생 가능까지 ${Math.ceil((3000 - S.focusSecondsSinceRebirth)/60)}분`);
      return;
    }
    const ok = confirm(
      `환생하시겠습니까?\n\n이번 생 최고 레벨: ${S.maxLevelThisLife}\nC0: ${S.c0.toFixed(2)} → ${(S.c0*1.1).toFixed(2)}\n\n(레벨 1 / 포인트 0 / 통합 요구량만 초기화)`
    );
    if (ok) doRebirth();
  });

  // save buttons
  $("#btnExport").addEventListener("click", async () => {
    if (S.isGrowing) { toast("집중 중에는 내보내기 불가 (정산 후 가능)"); return; }
    if ($("#battleOverlay").style.display === "block") { toast("전투 중에는 내보내기 불가"); return; }
    const code = encodeSave(S);
    const ok = await copyToClipboard(code);
    toast(ok ? "복사 완료" : "복사 실패");
  });

  function safeImportFromString(str){
    if (S.isGrowing) { toast("집중 중에는 가져올 수 없습니다. 먼저 정산하세요."); return; }
    if ($("#battleOverlay").style.display === "block") { toast("전투 중에는 가져올 수 없습니다."); return; }
    let imported;
    try { imported = decodeSave(str); }
    catch(e){ toast("가져오기 실패: " + (e.message || "형식 오류")); return; }

    S = Object.assign(structuredClone(DEFAULT), imported);

    // safety
    S.isGrowing = false;
    S.growStartAt = 0;

    if (!S.enemyType || S.enemyMAtk == null || S.enemyMDef == null) regenEnemyForLevel();

    save();
    render();
    toast("가져오기 완료");
  }

  $("#btnImport").addEventListener("click", () => {
    const str = prompt("가져오기 코드 붙여넣기");
    if (!str) return;
    safeImportFromString(str);
  });
  $("#btnImportClip").addEventListener("click", async () => {
    try {
      const str = await readFromClipboard();
      if (!str) { toast("클립보드가 비어있음"); return; }
      safeImportFromString(str);
    } catch(e) {
      toast("클립보드 읽기 실패(권한/사파리). 붙여넣기 사용");
    }
  });

  // battle mode choose
  $("#btnStartPhy").addEventListener("click", () => {
    if (!battle) return;
    battle.chosenMode = "phy";
    $("#modeChooser").style.display = "none";
    $("#modeFixed").style.display = "block";
    pushLog("START: PHY 고정", true);
    renderBattle();
    startBattleLoop();
  });
  $("#btnStartMag").addEventListener("click", () => {
    if (!battle) return;
    battle.chosenMode = "mag";
    $("#modeChooser").style.display = "none";
    $("#modeFixed").style.display = "block";
    pushLog("START: MAG 고정", true);
    renderBattle();
    startBattleLoop();
  });

  /* ---------- Upgrade UI ---------- */
  function makeBtn(text, onClick, enabled=true){
    const b = document.createElement("button");
    b.className = "mini";
    b.textContent = text;
    b.disabled = !enabled;
    b.addEventListener("click", onClick);
    return b;
  }

  function renderUpgrade(){
    $("#uPoints").textContent = fmtSci(S.points);
    $("#uCostHint").textContent =
      `통합 스탯 요구량(이번 생): bonusSpent=${S.bonusSpentThisLife} · 다음 +1 비용=${fmtSci(bonusCost(1))}`;

    $("#vATK").textContent = fmtSci(S.atk);
    $("#vDEF").textContent = fmtSci(S.def);
    $("#vMATK").textContent = fmtSci(S.matk);
    $("#vMDEF").textContent = fmtSci(S.mdef);

    $("#vCrit").textContent = `${S.critChance}%`;
    $("#vPen").textContent = `${S.penPct}%`;

    const canReb = rebirthReady();
    $("#vRebirth").textContent = canReb
      ? `가능 (최고Lv ${S.maxLevelThisLife})`
      : `불가 (남은 ${Math.ceil((3000 - S.focusSecondsSinceRebirth)/60)}분)`;

    renderBonusButtons("atk", "#bATK");
    renderBonusButtons("def", "#bDEF");
    renderBonusButtons("matk", "#bMATK");
    renderBonusButtons("mdef", "#bMDEF");

    renderExpButtons("crit", "#bCrit");
    renderExpButtons("pen", "#bPen");
  }

  function renderBonusButtons(key, containerSel){
    const el = $(containerSel);
    el.innerHTML = "";

    const cost1 = bonusCost(1);
    const cost10 = bonusCost(10);
    const cost100 = bonusCost(100);

    const can1 = cost1 <= S.points + 1e-9;
    const can10 = cost10 <= S.points + 1e-9;
    const can100 = cost100 <= S.points + 1e-9;

    el.appendChild(makeBtn("+1", () => { if(!applyBonus(key, 1)) toast("포인트 부족"); renderUpgrade(); }, can1));
    el.appendChild(makeBtn("+10", () => { if(!applyBonus(key, 10)) toast("포인트 부족"); renderUpgrade(); }, can10));
    el.appendChild(makeBtn("+100", () => { if(!applyBonus(key, 100)) toast("포인트 부족"); renderUpgrade(); }, can100));
  }

  function renderExpButtons(kind, containerSel){
    const el = $(containerSel);
    el.innerHTML = "";

    if (kind === "crit") {
      const can1 = expCost(S.critChance, 1) <= S.points + 1e-9 && S.critChance < 90;
      const can5 = expCost(S.critChance, Math.min(5, 90 - S.critChance)) <= S.points + 1e-9 && S.critChance < 90;

      el.appendChild(makeBtn("+1", () => { if(!applyCrit(1)) toast("포인트 부족"); renderUpgrade(); }, can1));
      el.appendChild(makeBtn("+5", () => { if(!applyCrit(5)) toast("포인트 부족"); renderUpgrade(); }, can5));
      return;
    }

    if (kind === "pen") {
      const can1 = expCost(S.penPct, 1) <= S.points + 1e-9 && S.penPct < 90;
      const can5 = expCost(S.penPct, Math.min(5, 90 - S.penPct)) <= S.points + 1e-9 && S.penPct < 90;

      el.appendChild(makeBtn("+1", () => { if(!applyPen(1)) toast("포인트 부족"); renderUpgrade(); }, can1));
      el.appendChild(makeBtn("+5", () => { if(!applyPen(5)) toast("포인트 부족"); renderUpgrade(); }, can5));
    }
  }

  /* ---------- Render ---------- */
  function render(){
    const live = $("#liveGain");
    $("#topLeft").textContent = `Enemy Lv ${S.enemyLevel} · ${S.enemyType}`;
    $("#topRight").textContent = `C0 ${fmt2(S.c0)} | C ${fmt2(currentC())}`;

    if (S.isGrowing) {
      const tSec = Math.max(0, Math.floor((now() - S.growStartAt)/1000));
      const eff = efficiencyPct(tSec);
      const E = eff / 100;
      const C = currentC();
      const gain = Math.floor(tSec * C * E);

      $("#points").textContent = fmtSci(S.points + gain);
      live.style.display = "block";
      live.textContent = `경과 ${fmtTime(tSec)} · +${fmtSci(gain)} (효율 ${eff}%)`;

      $("#status").textContent = "집중";
      $("#btnGrow").textContent = "정산하기";
      $("#btnUpgrade").disabled = true;
      $("#btnBattle").disabled = true;
    } else {
      $("#points").textContent = fmtSci(S.points);
      live.style.display = "none";
      live.textContent = "";

      $("#status").textContent = "대기";
      $("#btnGrow").textContent = "집중하기";
      $("#btnUpgrade").disabled = false;
      $("#btnBattle").disabled = false;
    }

    const mins = Math.floor(S.focusSecondsSinceRebirth / 60);
    $("#rebirthInfo").textContent =
      `환생: 누적 ${mins}분 / 50분 · 이번 생 최고 Lv ${S.maxLevelThisLife} · CRIT ${S.critChance}% · PEN ${S.penPct}%`;

    if ($("#upgradeOverlay").style.display === "block") renderUpgrade();
  }

  function renderBattle(){
    if (!battle) return;

    $("#turnLimit").textContent = TURN_LIMIT;
    $("#battleTop").textContent = `Enemy Lv ${S.enemyLevel} · ${battle.enemyType}`;

    const meHPpct = Math.max(0, Math.min(100, Math.floor((battle.meHP / battle.meMaxHP) * 100)));
    const enHPpct = Math.max(0, Math.min(100, Math.floor((battle.enemyHP / battle.enemyMaxHP) * 100)));
    $("#meHPpct").textContent = meHPpct;
    $("#enemyHPpct").textContent = enHPpct;
    $("#turn").textContent = battle.turn;

    $("#statLineMe").textContent =
      `ME: ATK ${fmtSci(S.atk)} DEF ${fmtSci(S.def)} MATK ${fmtSci(S.matk)} MDEF ${fmtSci(S.mdef)} · CRIT ${S.critChance}% PEN ${S.penPct}%`;

    $("#statLineEnemy").textContent =
      `ENEMY: ATK ${fmtSci(battle.enemyAtk)} DEF ${fmtSci(battle.enemyDef)} MATK ${fmtSci(battle.enemyMAtk)} MDEF ${fmtSci(battle.enemyMDef)}`;

    if (battle.chosenMode) {
      const recommend = (battle.enemyType === "MAG") ? "물리(DEF 낮을 확률↑)" : "마법(MDEF 낮을 확률↑)";
      $("#modeFixed").textContent =
        `이번 전투: ${battle.chosenMode === "phy" ? "물리" : "마법"} 고정 · 추천: ${recommend}`;
      $("#modeFixed").style.display = "block";
    }

    const logEl = $("#log");
    if (battle.log.length === 0) logEl.textContent = "";
    else {
      logEl.innerHTML = battle.log.map(x => {
        const cls = x.highlight ? "hl" : "";
        return `<div class="${cls}">${escapeHtml(x.line)}</div>`;
      }).join("");
      logEl.scrollTop = logEl.scrollHeight;
    }
  }

  function escapeHtml(s){
    return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  /* ---------- Persistence ---------- */
  function save(){
    try { localStorage.setItem(KEY, JSON.stringify(S)); } catch(e) {}
  }
  function loadMerged(){
    try {
      const raw = localStorage.getItem(KEY);
      if (!raw) return structuredClone(DEFAULT);

      const parsed = JSON.parse(raw);
      const merged = Object.assign(structuredClone(DEFAULT), parsed);

      // migrate: older fields safety
      if (merged.pen == null && merged.penPct == null) merged.penPct = 0;
      if (merged.penPct == null) merged.penPct = 0;
      if (merged.critChance == null && merged.crit == null) merged.critChance = 0;
      if (merged.critChance == null) merged.critChance = 0;
      if (merged.bonusSpentThisLife == null) merged.bonusSpentThisLife = 0;

      // normalize types
      merged.critChance = Math.max(0, Math.min(90, Math.floor(merged.critChance)));
      merged.penPct = Math.max(0, Math.min(90, Math.floor(merged.penPct)));

      return merged;
    } catch(e) {
      return structuredClone(DEFAULT);
    }
  }

  /* ---------- Boot ---------- */
  regenEnemyForLevel();
  render();

  // 성장중 화면 실시간 갱신
  setInterval(() => { if (S.isGrowing) render(); }, 500);

  // keep screen awake (if supported)
  let wakeLock = null;
  async function tryWakeLock(){
    try {
      if ("wakeLock" in navigator && !wakeLock) {
        wakeLock = await navigator.wakeLock.request("screen");
      }
    } catch(e) {}
  }
  document.addEventListener("visibilitychange", () => { if (!document.hidden) tryWakeLock(); });
  tryWakeLock();
})();
</script>
</body>
</html>
