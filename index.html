<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Focus Idle</title>
  <style>
    :root { --bg:#000; --fg:#fff; --muted:rgba(255,255,255,.65); --dim:rgba(255,255,255,.25); }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,AppleSDGothicNeo,Helvetica,Arial,sans-serif; }
    .app { height:100%; display:flex; flex-direction:column; }
    .top { padding:14px 16px 8px; font-size:12px; color:var(--muted); display:flex; justify-content:space-between; gap:10px; }
    .center { flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center; padding:16px; }
    .label { font-size:12px; color:var(--muted); letter-spacing:.12em; }
    .points { font-size:56px; font-weight:700; margin:10px 0 6px; }
    .status { margin-top:14px; font-size:14px; color:var(--muted); line-height:1.6; }
    .bottom { padding:10px 12px 16px; position:sticky; bottom:0; background:linear-gradient(to top, rgba(0,0,0,.95), rgba(0,0,0,.65), rgba(0,0,0,0)); }
    .btnrow { display:flex; gap:10px; }
    button {
      flex:1; border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.06); color:var(--fg);
      padding:14px 10px; border-radius:12px; font-size:14px;
      cursor:pointer;
    }
    button:disabled { opacity:.35; cursor:not-allowed; }
    .overlay, .modal {
      position:fixed; inset:0; background:rgba(0,0,0,.92);
      display:none; z-index:20;
    }
    .panel {
      max-width:520px; margin:0 auto; height:100%;
      display:flex; flex-direction:column;
    }
    .panelTop { padding:14px 16px; display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid rgba(255,255,255,.14); }
    .panelTop h2 { margin:0; font-size:14px; font-weight:700; letter-spacing:.06em; color:var(--fg); }
    .panelTop button { flex:0 0 auto; padding:10px 12px; border-radius:10px; }
    .panelBody { padding:14px 16px; overflow:auto; }
    .row { padding:12px 0; border-bottom:1px solid rgba(255,255,255,.10); }
    .rowHead { display:flex; justify-content:space-between; align-items:baseline; gap:10px; }
    .rowHead .name { font-size:13px; color:var(--muted); }
    .rowHead .val { font-size:18px; font-weight:700; }
    .rowBtns { display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
    .mini { flex:0 0 auto; padding:10px 12px; border-radius:10px; font-size:13px; }
    .hint { margin:8px 0 0; color:var(--dim); font-size:12px; }
    .toast {
      position:fixed; left:50%; bottom:92px; transform:translateX(-50%);
      background:rgba(255,255,255,.10); border:1px solid rgba(255,255,255,.18);
      color:var(--fg); padding:10px 12px; border-radius:12px; font-size:13px;
      display:none; z-index:50;
      max-width:min(520px, calc(100% - 24px));
    }
    /* Battle */
    .battleBox { padding:16px; }
    .bigline { font-size:16px; font-weight:700; margin:8px 0 12px; }
    .hpbox { display:flex; justify-content:space-between; gap:12px; color:var(--muted); font-size:13px; }
    .hpn { font-size:20px; color:var(--fg); font-weight:700; margin-top:6px; }
    .log { margin-top:14px; color:var(--muted); font-size:14px; line-height:1.7; min-height:48px; }
    .crit { color:var(--fg); }
    .resultCenter { height:100%; display:flex; flex-direction:column; justify-content:center; align-items:center; text-align:center; padding:18px; gap:10px; }
    .resultTitle { font-size:28px; font-weight:800; }
    .resultSub { color:var(--muted); font-size:14px; line-height:1.6; }
    .overkill { margin-top:8px; font-weight:800; letter-spacing:.08em; }
    .skipLine { color:var(--muted); font-size:14px; min-height:22px; }
    .confirmBtn { width:min(320px, 92%); }
    .smallTop { color:var(--muted); font-size:12px; }
    a.link { color:var(--muted); text-decoration:underline; }
  </style>
</head>
<body>
<div class="app">
  <div class="top">
    <div id="topLeft">Enemy Lv 1</div>
    <div id="topRight">C0 5.00 | C 5.00</div>
  </div>

  <div class="center">
    <div class="label">POINTS</div>
    <div class="points" id="points">0</div>
    <div class="status" id="liveGain" style="margin-top:6px; font-size:13px; color:rgba(255,255,255,.55); display:none;"></div>
    <div class="status" id="status"></div>
    <div class="status" id="rebirthInfo" style="margin-top:10px; color:rgba(255,255,255,.35); font-size:12px;"></div>
  </div>

  <div class="bottom">
    <div class="btnrow">
      <button id="btnUpgrade">업그레이드</button>
      <button id="btnBattle">전투</button>
      <button id="btnGrow">성장중</button>
    </div>
  </div>
</div>

<div class="overlay" id="upgradeOverlay" aria-hidden="true">
  <div class="panel">
    <div class="panelTop">
      <h2>업그레이드</h2>
      <button id="btnUpgradeClose" class="mini">닫기</button>
    </div>
    <div class="panelBody">
      <div class="row">
        <div class="rowHead">
          <div class="name">포인트</div>
          <div class="val" id="uPoints">0</div>
        </div>
      </div>

      <div class="row" id="rowATK">
        <div class="rowHead"><div class="name">ATK</div><div class="val" id="vATK">0</div></div>
        <div class="rowBtns" id="bATK"></div>
      </div>

      <div class="row" id="rowDEF">
        <div class="rowHead"><div class="name">DEF</div><div class="val" id="vDEF">0</div></div>
        <div class="rowBtns" id="bDEF"></div>
      </div>

      <div class="row" id="rowHP">
        <div class="rowHead"><div class="name">HP</div><div class="val" id="vHP">0</div></div>
        <div class="rowBtns" id="bHP"></div>
      </div>

      <div class="row" id="rowCrit">
        <div class="rowHead"><div class="name">CRIT%</div><div class="val" id="vCrit">0%</div></div>
        <div class="rowBtns" id="bCrit"></div>
        <div class="hint">0% 시작, 상한 90%, 비용 10×2^현재%</div>
      </div>

      <div class="row" id="rowCritDmg">
        <div class="rowHead"><div class="name">CRIT+</div><div class="val" id="vCritDmg">+50%</div></div>
        <div class="rowBtns" id="bCritDmg"></div>
        <div class="hint">추가 피해량 +50% 시작, +5% 단위, 상한 없음, 비용 10×2^업횟수</div>
      </div>

      <div class="row">
        <div class="rowHead"><div class="name">환생</div><div class="val" id="vRebirth">-</div></div>
        <div class="rowBtns">
          <button id="btnRebirth" class="mini">환생</button>
        </div>
        <div class="hint">조건: 환생 이후 성장 누적 50분(3000초) 이상</div>
      </div>

      <div class="row">
        <div class="hint">Tip: 아이폰에서 탭이 꺼지거나 다른 앱으로 가면 자동 정산 후 성장 종료됩니다.</div>
      </div>
    </div>
  </div>
</div>

<div class="overlay" id="battleOverlay" aria-hidden="true">
  <div class="panel">
    <div class="panelTop">
      <h2>전투</h2>
      <button id="btnBattleExit" class="mini">나가기</button>
    </div>
    <div class="panelBody battleBox">
      <div class="smallTop" id="battleTop">Enemy Lv 1</div>
      <div class="bigline" id="enemyLine">E: ATK 0 DEF 0 HP 0</div>

      <div class="hpbox">
        <div style="flex:1;">
          <div>적 HP</div>
          <div class="hpn" id="enemyHP">0/0</div>
        </div>
        <div style="flex:1;">
          <div>내 HP</div>
          <div class="hpn" id="meHP">0/0</div>
        </div>
      </div>

      <div class="status" style="margin-top:10px;">
        TURN <span id="turn">0</span>/<span id="turnLimit">20</span>
      </div>

      <div class="log" id="log"></div>

      <div style="margin-top:16px;">
        <button id="btnAttack">공격</button>
      </div>
    </div>
  </div>
</div>

<div class="modal" id="resultModal" aria-hidden="true">
  <div class="resultCenter">
    <div class="resultTitle" id="resultTitle">승리</div>
    <div class="resultSub" id="resultSub">-</div>
    <div class="overkill" id="overkill" style="display:none;">OVERKILL!</div>
    <div class="skipLine" id="skipLine"></div>
    <button id="btnConfirm" class="confirmBtn">확인</button>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
(() => {
  const KEY = "focus_idle_v1";

  // ---------- Utilities ----------
  const now = () => Date.now();
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const fmt = (n) => {
    if (typeof n !== "number") return String(n);
    // 큰 수는 간단히
    if (n >= 1e9) return (n/1e9).toFixed(2) + "B";
    if (n >= 1e6) return (n/1e6).toFixed(2) + "M";
    if (n >= 1e3) return Math.floor(n).toLocaleString("en-US");
    return (Math.floor(n)).toString();
  };
  const fmt2 = (n) => (Math.round(n * 100) / 100).toFixed(2);

  function toast(msg) {
    const el = $("#toast");
    el.textContent = msg;
    el.style.display = "block";
    clearTimeout(toast._t);
    toast._t = setTimeout(() => el.style.display = "none", 900);
  }

  function $(sel){ return document.querySelector(sel); }

  // ---------- Core State ----------
  const DEFAULT = {
    points: 0,
    // player stats
    atk: 5,
    def: 5,
    hp: 100,
    // crit
    critChance: 0,      // %
    critDmgUp: 0,       // upgrades count; bonus = 50 + 5*critDmgUp
    // enemy progression
    enemyLevel: 1,
    enemyBasePower: 30,
    enemySeed: 0,       // for future if needed
    enemyAtk: 10,
    enemyDef: 20,
    // growth
    isGrowing: false,
    growStartAt: 0,
    // rebirth / meta
    c0: 5.0,
    maxLevelThisLife: 1,
    focusSecondsSinceRebirth: 0,
    rebirthCount: 0
  };

  let S = load();


  // ---------- Derived ----------
  function enemyPowerForLevel(level){
    const k = level - 1;
    return Math.floor(S.enemyBasePower * Math.pow(1.1, k));
  }

  function currentC(){
    // C(L) = C0 + floor((Lv-1)/3)
    return S.c0 + Math.floor((S.enemyLevel - 1) / 3);
  }

  function efficiencyPct(tSec){
    if (tSec >= 300) return 100;
    if (tSec >= 180) return 80;
    if (tSec >= 120) return 60;
    if (tSec >= 60)  return 40;
    return 20;
  }

  function playerPower(){
    return S.atk + S.def + (S.hp / 10);
  }

  function enemyPowerMetric(power){
    // P_enemy = 2 * enemyPower
    return 2 * power;
  }

  function critBonusPct(){
    return 50 + 5 * S.critDmgUp; // "추가 피해량"
  }

  // ---------- Enemy generation ----------
  function regenEnemyForLevel(){
    const power = enemyPowerForLevel(S.enemyLevel);
    const r = 0.35 + Math.random() * 0.30; // [0.35, 0.65]
    const atk = Math.max(1, Math.round(power * r));
    const def = Math.max(0, power - atk);
    S.enemyAtk = atk;
    S.enemyDef = def;
    // HP = (ATK+DEF)*10 = power*10
    save();
  }

  // Ensure enemy is initialized
  if (!S.enemyAtk || !S.enemyDef) regenEnemyForLevel();

  // ---------- Growth ----------
  function startGrowth(){
    if (S.isGrowing) return;
    S.isGrowing = true;
    S.growStartAt = now();
    save();
    render();
  }

  function settleGrowth(){
    if (!S.isGrowing) return;
    const tSec = Math.max(0, Math.floor((now() - S.growStartAt) / 1000));
    const E = efficiencyPct(tSec) / 100;
    const C = currentC();
    const gain = Math.floor(tSec * C * E);

    S.points += gain;
    S.focusSecondsSinceRebirth += tSec;

    S.isGrowing = false;
    S.growStartAt = 0;
    save();
    render();
    if (tSec > 0) toast(`정산 +${fmt(gain)} (${tSec}s, ${Math.round(E*100)}%)`);
  }

  // If tab becomes hidden, settle and stop.
  document.addEventListener("visibilitychange", () => {
    if (document.hidden) settleGrowth();
  });
  window.addEventListener("pagehide", () => settleGrowth());

  // ---------- Upgrade costs ----------
  function seriesCostLinear(s, n, factor){
    // factor * sum_{i=0..n-1} (s+i) = factor * n*(2s+n-1)/2
    return factor * (n * (2*s + n - 1) / 2);
  }

  function maxAffordableN(s, factor, points){
    // Find max n such that factor * n*(2s+n-1)/2 <= points
    // Solve n^2 + (2s-1)n - (2*points/factor) <= 0
    const B = (2*s - 1);
    const C = -(2 * (points / factor));
    const disc = B*B - 4*1*C;
    if (disc < 0) return 0;
    const n = Math.floor((-B + Math.sqrt(disc)) / 2);
    return Math.max(0, n);
  }

  function applyUpgrade(statKey, n){
    if (n <= 0) return false;

    if (statKey === "atk" || statKey === "def") {
      const s = S[statKey];
      const cost = seriesCostLinear(s, n, 10);
      if (cost > S.points + 1e-9) return false;
      S.points -= cost;
      S[statKey] += n;
      save(); render();
      return true;
    }
    if (statKey === "hp") {
      const s = S.hp;
      const cost = seriesCostLinear(s, n, 1);
      if (cost > S.points + 1e-9) return false;
      S.points -= cost;
      S.hp += n;
      save(); render();
      return true;
    }
    return false;
  }

  // Crit chance: +1% costs 10*2^current%
  function critChanceCost(c){ return 10 * Math.pow(2, c); }

  function applyCritChance(delta){
    if (delta <= 0) return false;
    const target = Math.min(90, S.critChance + delta);
    const realDelta = target - S.critChance;
    if (realDelta <= 0) return false;

    // sum costs for each +1
    let cost = 0;
    for (let i=0;i<realDelta;i++){
      cost += critChanceCost(S.critChance + i);
      if (cost > S.points + 1e-9) return false;
    }
    S.points -= cost;
    S.critChance += realDelta;
    save(); render();
    return true;
  }

  // Crit dmg upgrades: each upgrade adds +5% bonus, cost 10*2^k where k=current upgrades
  function critDmgCost(k){ return 10 * Math.pow(2, k); }

  function applyCritDmgUp(deltaUpgrades){
    if (deltaUpgrades <= 0) return false;
    let cost = 0;
    for (let i=0;i<deltaUpgrades;i++){
      cost += critDmgCost(S.critDmgUp + i);
      if (cost > S.points + 1e-9) return false;
    }
    S.points -= cost;
    S.critDmgUp += deltaUpgrades;
    save(); render();
    return true;
  }

  // ---------- Battle ----------
  const TURN_LIMIT = 20;
  let battle = null;

  function openBattle(){
    if (S.isGrowing) return;
    // Initialize battle state (full HP at start)
    const power = enemyPowerForLevel(S.enemyLevel);
    const enemyMaxHP = power * 10;
    battle = {
      enemyPower: power,
      enemyAtk: S.enemyAtk,
      enemyDef: S.enemyDef,
      enemyMaxHP,
      enemyHP: enemyMaxHP,
      meMaxHP: S.hp,
      meHP: S.hp,
      turn: 0,
      firstTurn: true,
      log: []
    };
    showBattle(true);
    renderBattle();
  }

  function dmgPlayerToEnemy(){
    const base = Math.max(1, S.atk - battle.enemyDef);
    const roll = Math.random() * 100;
    const isCrit = roll < S.critChance;
    const mult = isCrit ? (1 + (critBonusPct()/100)) : 1;
    const dmg = Math.max(1, Math.floor(base * mult));
    return { dmg, isCrit };
  }

  function dmgEnemyToPlayer(){
    return Math.max(1, battle.enemyAtk - S.def);
  }

  function pushLog(line, isCrit=false){
    battle.log.push({ line, isCrit });
    if (battle.log.length > 2) battle.log.shift();
  }

  async function doAttackTurn(){
    if (!battle) return;
    if ($("#btnAttack").disabled) return;

    battle.turn += 1;

    // Player attacks
    const { dmg, isCrit } = dmgPlayerToEnemy();
    battle.enemyHP = Math.max(0, battle.enemyHP - dmg);
    pushLog(`${isCrit ? "CRIT! " : ""}You: -${dmg}`, isCrit);

    // If enemy dead, end
    if (battle.enemyHP <= 0) {
      const oneTurnKill = (battle.turn === 1);
      await endBattle(true, oneTurnKill);
      return;
    }

    // Enemy attacks
    const edmg = dmgEnemyToPlayer();
    battle.meHP = Math.max(0, battle.meHP - edmg);
    pushLog(`Enemy: -${edmg}`, false);

    // End checks
    if (battle.meHP <= 0) {
      await endBattle(false, false);
      return;
    }
    if (battle.turn >= TURN_LIMIT) {
      await endBattle(false, false, true);
      return;
    }

    renderBattle();
  }

  function ratioNowForOverkill(){
    const Pme = playerPower();
    const Penemy = enemyPowerMetric(battle.enemyPower); // 2*enemyPower
    return Pme / Penemy;
  }

  async function endBattle(win, oneTurnKill, timeout=false){
    // Track max level achieved (on win only, before level changes)
    if (win) {
      S.maxLevelThisLife = Math.max(S.maxLevelThisLife, S.enemyLevel);
    }

    showBattle(false);

    // Build result text
    let title = win ? "승리" : "패배";
    let sub = "";
    if (timeout) {
      sub = `턴 초과 · 적 HP ${Math.round((battle.enemyHP / battle.enemyMaxHP)*100)}%`;
    } else {
      sub = `적 HP ${Math.round((battle.enemyHP / battle.enemyMaxHP)*100)}% · 턴 ${battle.turn}/${TURN_LIMIT}`;
    }

    $("#resultTitle").textContent = title;
    $("#resultSub").textContent = sub;
    $("#overkill").style.display = "none";
    $("#skipLine").textContent = "";

    // Level progression
    if (win) {
      if (oneTurnKill) {
        // Overkill jump to reach ratio <= 1.0
        const ratioNow = ratioNowForOverkill();
        const k = ratioNow > 1 ? Math.ceil(Math.log(ratioNow) / Math.log(1.1)) : 0;

        if (k > 0) {
          $("#overkill").style.display = "block";
          await animateSkip(k);
          S.enemyLevel += k;
          // apply power increase implicitly via level; regen stats
          regenEnemyForLevel();
        } else {
          // even if oneTurnKill but ratio<=1 (rare), just +1 level
          S.enemyLevel += 1;
          regenEnemyForLevel();
        }
      } else {
        S.enemyLevel += 1;
        regenEnemyForLevel();
      }
      // update max after level changes too, because reaching new level matters as "maxLevel"
      S.maxLevelThisLife = Math.max(S.maxLevelThisLife, S.enemyLevel);
      save();
      render();
    }

    showResult(true);
    battle = null;
  }

  function showResult(on){
    $("#resultModal").style.display = on ? "block" : "none";
  }

  function showUpgrade(on){
    $("#upgradeOverlay").style.display = on ? "block" : "none";
    $("#upgradeOverlay").setAttribute("aria-hidden", on ? "false" : "true");
  }

  function showBattle(on){
    $("#battleOverlay").style.display = on ? "block" : "none";
    $("#battleOverlay").setAttribute("aria-hidden", on ? "false" : "true");
  }

  async function animateSkip(k){
    $("#skipLine").textContent = "";
    // Show +1 +2 ... quickly, but cap to avoid long spam
    const showCount = Math.min(k, 18);
    for (let i=1; i<=showCount; i++){
      $("#skipLine").textContent = `+${i}`;
      await sleep(35);
    }
    if (k > showCount) {
      $("#skipLine").textContent = `+${showCount} …`;
      await sleep(120);
    }
    $("#skipLine").textContent = `+${k} level!!!`;
    await sleep(220);
  }

  function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

  // ---------- Rebirth ----------
  function rebirthReady(){
    return S.focusSecondsSinceRebirth >= 3000;
  }

  function doRebirth(){
    if (!rebirthReady()) {
      toast("환생 조건 미달 (성장 누적 50분 필요)");
      return;
    }
    // ΔC0 = maxLevel / 100, accumulate
    const delta = S.maxLevelThisLife / 100;
    S.c0 += delta;

    // reset run
    S.rebirthCount += 1;
    S.focusSecondsSinceRebirth = 0;
    S.maxLevelThisLife = 1;

    // reset stats & progression
    S.points = 0;
    S.atk = 5; S.def = 5; S.hp = 100;
    S.critChance = 0; S.critDmgUp = 0;

    S.enemyLevel = 1;
    regenEnemyForLevel();

    save();
    render();
    toast(`환생! ΔC0 +${fmt2(delta)} (C0 ${fmt2(S.c0)})`);
  }

  // ---------- UI Wiring ----------
  $("#btnGrow").addEventListener("click", () => {
    if (S.isGrowing) settleGrowth();
    else startGrowth();
  });

  $("#btnUpgrade").addEventListener("click", () => {
    if (S.isGrowing) return;
    showUpgrade(true);
    renderUpgrade();
  });

  $("#btnUpgradeClose").addEventListener("click", () => showUpgrade(false));

  $("#btnBattle").addEventListener("click", () => {
    if (S.isGrowing) return;
    openBattle();
  });

  $("#btnBattleExit").addEventListener("click", () => {
    // leaving battle does not change anything; just close
    showBattle(false);
    battle = null;
  });

  $("#btnAttack").addEventListener("click", () => doAttackTurn());

  $("#btnConfirm").addEventListener("click", () => {
    showResult(false);
    render();
  });

  $("#btnRebirth").addEventListener("click", () => {
    if (!rebirthReady()) {
      toast(`환생 가능까지 ${Math.ceil((3000 - S.focusSecondsSinceRebirth)/60)}분`);
      return;
    }
    // simple confirm
    const delta = S.maxLevelThisLife / 100;
    const ok = confirm(`환생하시겠습니까?\n\n이번 생 최고 레벨: ${S.maxLevelThisLife}\nΔC0 = ${delta.toFixed(2)}\nC0: ${S.c0.toFixed(2)} → ${(S.c0+delta).toFixed(2)}\n\n(레벨/스탯/포인트 리셋)`);
    if (ok) doRebirth();
  });

  // ---------- Upgrade Buttons ----------
  function makeBtn(text, onClick, enabled=true){
    const b = document.createElement("button");
    b.className = "mini";
    b.textContent = text;
    b.disabled = !enabled;
    b.addEventListener("click", onClick);
    return b;
  }

  function renderUpgrade(){
    $("#uPoints").textContent = fmt(S.points);

    $("#vATK").textContent = S.atk;
    $("#vDEF").textContent = S.def;
    $("#vHP").textContent = S.hp;

    $("#vCrit").textContent = `${S.critChance}%`;
    $("#vCritDmg").textContent = `+${critBonusPct()}%`;

    const canReb = rebirthReady();
    $("#vRebirth").textContent = canReb
      ? `가능 (최고Lv ${S.maxLevelThisLife}, ΔC0 ${(S.maxLevelThisLife/100).toFixed(2)})`
      : `불가 (남은 ${Math.ceil((3000 - S.focusSecondsSinceRebirth)/60)}분)`;

    renderStatButtons("atk", "#bATK");
    renderStatButtons("def", "#bDEF");
    renderStatButtons("hp",  "#bHP");
    renderCritButtons();
    renderCritDmgButtons();
  }

  function renderStatButtons(key, containerSel){
  const el = $(containerSel);
  el.innerHTML = "";
  const v = S[key];

  const factor = (key === "hp") ? 1 : 10;
  const s = S[key];

  const cost1 = seriesCostLinear(s, 1, factor);
  const cost10 = seriesCostLinear(s, 10, factor);
  const cost100 = seriesCostLinear(s, 100, factor);

  const can1 = cost1 <= S.points + 1e-9;
  const can10 = cost10 <= S.points + 1e-9;

  const bigEnabled = v >= 100;
  const can100 = bigEnabled && (cost100 <= S.points + 1e-9);

  const nMax = maxAffordableN(s, factor, S.points);
  const canMax = bigEnabled && nMax > 0;

  const add = (n) => {
    const ok = applyUpgrade(key, n);
    if (!ok) toast("포인트 부족");
    renderUpgrade();
  };

  el.appendChild(makeBtn("+1", () => add(1), can1));
  el.appendChild(makeBtn("+10", () => add(10), can10));
  el.appendChild(makeBtn("+100", () => add(100), can100));

  el.appendChild(makeBtn("MAX", () => {
    if (nMax <= 0) { toast("포인트 부족"); return; }
    applyUpgrade(key, nMax);
    renderUpgrade();
  }, canMax));
}


function renderCritButtons(){
  const el = $("#bCrit");
  el.innerHTML = "";
  const canInc = S.critChance < 90;

  const can1 = canInc && (critChanceCost(S.critChance) <= S.points + 1e-9);

  // +5는 5번 비용 합이 필요하니 계산
  let cost5 = 0, can5 = false;
  if (canInc) {
    const realDelta = Math.min(5, 90 - S.critChance);
    for (let i=0;i<realDelta;i++) cost5 += critChanceCost(S.critChance + i);
    can5 = cost5 <= S.points + 1e-9;
  }

  el.appendChild(makeBtn("+1", () => {
    const ok = applyCritChance(1);
    if (!ok) toast("포인트 부족");
    renderUpgrade();
  }, can1));

  el.appendChild(makeBtn("+5", () => {
    const ok = applyCritChance(5);
    if (!ok) toast("포인트 부족");
    renderUpgrade();
  }, can5));
}


function renderCritDmgButtons(){
  const el = $("#bCritDmg");
  el.innerHTML = "";

  const can1 = critDmgCost(S.critDmgUp) <= S.points + 1e-9;

  let cost5 = 0;
  for (let i=0;i<5;i++) cost5 += critDmgCost(S.critDmgUp + i);
  const can5 = cost5 <= S.points + 1e-9;

  el.appendChild(makeBtn("+1", () => {
    const ok = applyCritDmgUp(1);
    if (!ok) toast("포인트 부족");
    renderUpgrade();
  }, can1));

  el.appendChild(makeBtn("+5", () => {
    const ok = applyCritDmgUp(5);
    if (!ok) toast("포인트 부족");
    renderUpgrade();
  }, can5));
}


  // ---------- Render ----------
function pad2(n){ return String(n).padStart(2,"0"); }
function fmtTime(sec){
  const m = Math.floor(sec/60);
  const s = sec%60;
  return `${pad2(m)}:${pad2(s)}`;
}

function render(){
  const live = $("#liveGain");

  $("#topLeft").textContent = `Enemy Lv ${S.enemyLevel}`;
  $("#topRight").textContent = `C0 ${fmt2(S.c0)} | C ${fmt2(currentC())}`;

  if (S.isGrowing) {
    const tSec = Math.max(0, Math.floor((now() - S.growStartAt)/1000));
    const eff = efficiencyPct(tSec);
    const E = eff / 100;
    const C = currentC();
    const gain = Math.floor(tSec * C * E);

    // 큰 숫자: 예상 누적 포인트(현재 + 누적)
    $("#points").textContent = fmt(S.points + gain);

    // 보조 줄: 타이머 + 예상치
    live.style.display = "block";
    live.textContent = `경과 ${fmtTime(tSec)} · +${fmt(gain)} (효율 ${eff}%)`;

    $("#status").textContent = "성장중";
    $("#btnGrow").textContent = "정산하기";
    $("#btnUpgrade").disabled = true;
    $("#btnBattle").disabled = true;
  } else {
    $("#points").textContent = fmt(S.points);

    live.style.display = "none";
    live.textContent = "";

    $("#status").textContent = "대기";
    $("#btnGrow").textContent = "성장중";
    $("#btnUpgrade").disabled = false;
    $("#btnBattle").disabled = false;
  }

  const mins = Math.floor(S.focusSecondsSinceRebirth / 60);
  $("#rebirthInfo").textContent =
    `환생: 누적 ${mins}분 / 50분 · 이번 생 최고 Lv ${S.maxLevelThisLife} · ΔC0 ${(S.maxLevelThisLife/100).toFixed(2)}`;

  if ($("#upgradeOverlay").style.display === "block") renderUpgrade();
}


  function renderBattle(){
    if (!battle) return;
    $("#battleTop").textContent = `Enemy Lv ${S.enemyLevel}`;
    $("#enemyLine").textContent = `E: ATK ${battle.enemyAtk} DEF ${battle.enemyDef} HP ${battle.enemyMaxHP}`;
    $("#enemyHP").textContent = `${battle.enemyHP}/${battle.enemyMaxHP}`;
    $("#meHP").textContent = `${battle.meHP}/${battle.meMaxHP}`;
    $("#turn").textContent = battle.turn;
    $("#turnLimit").textContent = TURN_LIMIT;

    // log
    const logEl = $("#log");
    if (battle.log.length === 0) {
      logEl.textContent = "";
    } else {
      logEl.innerHTML = battle.log.map(x => {
        const cls = x.isCrit ? "crit" : "";
        return `<div class="${cls}">${escapeHtml(x.line)}</div>`;
      }).join("");
    }

    // disable attack if battle ended (shouldn't happen)
    $("#btnAttack").disabled = false;
  }

  function escapeHtml(s){
    return s.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  // ---------- Persistence ----------
  function save(){
    try { localStorage.setItem(KEY, JSON.stringify(S)); } catch(e) {}
  }
  function load(){
    try {
      const raw = localStorage.getItem(KEY);
      if (!raw) {
        const s = structuredClone(DEFAULT);
        // init enemy
        s.enemyLevel = 1;
        s.enemyAtk = 0; s.enemyDef = 0;
        return s;
      }
      const s = Object.assign(structuredClone(DEFAULT), JSON.parse(raw));
      return s;
    } catch(e) {
      return structuredClone(DEFAULT);
    }
  }

  // ---------- Boot ----------
  regenEnemyForLevel();
  render();

  // Optional: keep screen awake (if supported)
  // (Not required, since you said "screen-on", but it helps.)
  let wakeLock = null;
  async function tryWakeLock(){
    try {
      if ("wakeLock" in navigator && !wakeLock) {
        wakeLock = await navigator.wakeLock.request("screen");
      }
    } catch(e) { /* ignore */ }
  }
  document.addEventListener("visibilitychange", () => {
    if (!document.hidden) tryWakeLock();
  });
  tryWakeLock();
})();
</script>
</body>
</html>
